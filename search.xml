<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CentOS7调优实践</title>
    <url>/2021/10/05/CentOS7%E8%B0%83%E4%BC%98%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>如何使一台服务器充分发挥它的性能，其实是有很多讲究的。除了提升它的硬件配置，包括CPU、内存、硬盘、网络带宽等，也还需要合理设置它的操作系统参数，只有软硬件都设置得当，才能发挥最大能力。</p>
<p>这里不对如何进行硬件配置的优化展开讲，我们讲的主要还是操作系统层次的设置优化。参考官方性能调优指南：<a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html-single/performance_tuning_guide/index">https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html-single/performance_tuning_guide/index</a>。</p>
<h2 id="具体调优点"><a href="#具体调优点" class="headerlink" title="具体调优点"></a>具体调优点</h2><p>常见需要调优的有如下几类，具体在后面会详细介绍如何调整：</p>
<ul>
<li>调整文件数限制<ul>
<li>fs.file_max：允许打开的最大文件数，在linux中一切皆文件，所以要最大化利用计算机资源需要调大这个数值</li>
<li>其他：在/etc/security/limits.conf中调整linux系统用户可打开的文件数</li>
</ul>
</li>
<li>调整网络参数：<ul>
<li>调整端口范围，修改net.ipv4.ip_local_port_range，设置为一个较大范围</li>
<li>修改net.core.somaxconn：这个参数是优化最大允许同时连接数</li>
<li>net.ipv4.tcp_max_syn_backlog</li>
<li>net.core.netdev_max_backlog</li>
</ul>
</li>
<li>其他优化</li>
</ul>
<h3 id="查看系统内核参数的方法"><a href="#查看系统内核参数的方法" class="headerlink" title="查看系统内核参数的方法"></a>查看系统内核参数的方法</h3><p>一种方法是在/etc/sysctl.conf看，但是有些参数没有被显示配置，但是在系统中是有默认值的，那么就可以使用<code>sysctl</code>命令查看该参数的数值。</p>
<p>常用的命令：</p>
<ul>
<li>sysctl -a：查看所有内核参数</li>
<li>sysctl -N ${name}：查看某个参数是否存在，比如sysctl -N net.core.somaxconn</li>
<li>sysctl -n ${name}：查看某个参数的具体值，比如sysctl -n net.core.somaxconn</li>
<li>sysctl -w ${name}=${value}：临时设置某个参数的具体值，比如sysctl -w net.core.somaxconn=65535 注意值是有类型的，比如无符号短整型</li>
<li>sysctl -p：重新加载这个配置文件</li>
</ul>
<h3 id="调整文件数限制"><a href="#调整文件数限制" class="headerlink" title="调整文件数限制"></a>调整文件数限制</h3><p>编辑/etc/security/limits.conf，修改文件数限制：</p>
<ul>
<li>查看最大可打开文件书：cat /proc/sys/fs/file-max</li>
<li>修改/etc/security/limits.conf限制，最后添加<code>root    -       nofile  1000000</code></li>
<li>执行ulimit -n 1000000动态修改文件数限制，和上面第二部结合起来，就不需要重启电脑</li>
</ul>
<p>对于上述第二点，可能需要设置其他用户或所有用户的打开文件数限制，可以通过添加<code>*    -       nofile  1000000</code>为所有用户打开限制。</p>
<h3 id="修改网络参数"><a href="#修改网络参数" class="headerlink" title="修改网络参数"></a>修改网络参数</h3><h4 id="调整端口范围"><a href="#调整端口范围" class="headerlink" title="调整端口范围"></a>调整端口范围</h4><p>默认的端口打开范围是3万多到6万多，调整为从10000到65535：<code>net.ipv4.ip_local_port_range = 10000 65535</code></p>
<p>后面如果没有提到修改哪个文件，默认就是修改/etc/sysctl.conf。</p>
<h4 id="修改允许连接的最大数"><a href="#修改允许连接的最大数" class="headerlink" title="修改允许连接的最大数"></a>修改允许连接的最大数</h4><p>首先查看网络允许连接的最大数：<code>sysctl -n net.core.somaxconn</code>，发现只有128，因此需要调整，调整为10万应该够了：<code>sysctl -w net.core.somaxconn=100000</code>。</p>
<p>设置的时候遇到<code>sysctl: setting key &quot;net.core.somaxconn&quot;: 无效的参数</code>错误。经过搜索了解，somaxconn值类型是USHRT（无符号短整型），最大值不应超过65535(USHRT_MAX)。</p>
<p>经过测试，确实如此，因为当我把该参数值设为65536的时候失败了，而65535可以成功。测试通过。</p>
<p>设置成功后的输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@hadoop2 ~]<span class="comment"># sysctl -w net.core.somaxconn=65535</span></span><br><span class="line">net.core.somaxconn = 65535</span><br></pre></td></tr></table></figure>

<p>记得在/etc/sysctl.conf中配置，否则重启后上述临时设置会失效。在该文件增加<code>net.core.somaxconn = 65535</code>。</p>
<p>据说也有办法可以调整，如果真的需要调整，可能需要打补丁，这点没有测试过，不做保证。参考：<a href="https://lists.ubuntu.com/archives/kernel-team/2013-October/033041.html">https://lists.ubuntu.com/archives/kernel-team/2013-October/033041.html</a></p>
<h4 id="修改发送和接收队列数"><a href="#修改发送和接收队列数" class="headerlink" title="修改发送和接收队列数"></a>修改发送和接收队列数</h4><p>在<code>/etc/sysctl.conf</code>设置：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">net.ipv4.tcp_max_syn_backlog</span> = <span class="string">262144</span></span><br><span class="line"><span class="meta">net.core.netdev_max_backlog</span> = <span class="string">262144</span></span><br></pre></td></tr></table></figure>

<p><code>tcp_max_syn_backlog</code>指Tcp syn队列的最大长度，与tcp连接建立时的三次握手相关。</p>
<p>参数<code>net.core.netdev_max_backlog</code>表示当每个网络接口接受数据包的速率比内核处理这些包的速率快时，允许接收队列（原文是INPUT side）的数据包的最大数目，我们调整为262144。</p>
<p>设置完成后执行<code>sysctl -p</code>加载配置。</p>
<p>相关解释：</p>
<ul>
<li>中文材料：<a href="http://www.lmyw.net.cn/?p=1390">http://www.lmyw.net.cn/?p=1390</a></li>
<li>看起来是官方内核参数手册：<a href="https://www.kernel.org/doc/html/latest/admin-guide/sysctl/net.html?highlight=netdev_max_backlog">https://www.kernel.org/doc/html/latest/admin-guide/sysctl/net.html?highlight=netdev_max_backlog</a></li>
</ul>
<h3 id="使用tuned工具调优服务器"><a href="#使用tuned工具调优服务器" class="headerlink" title="使用tuned工具调优服务器"></a>使用tuned工具调优服务器</h3><p>tuned是什么？是一款用于优化Linux系统性能的工具，可以配置cockpit使用。该工具相当于对服务器的运行模式做了调整，并不能替代上述我们所做的操作。</p>
<p>tuned并不是系统自带，需要另行安装。</p>
<p>执行命令<code>tuned-adm active</code>可以查看活跃的性能配置。另外，tuned可以设置多个profile，但是目前发现如果使用<code>tuned-admin profile a b c</code>这个命令设置throughput-performance和其他profile混用，则命令会报错。</p>
<p>对于需要充当服务器角色的机器，应该设置为<code>throughput-performance</code>配置类型，如果是使用vmware创建的虚拟机，默认应该是<code>virtual-guest</code>。</p>
<p>那么问题来了，调了以后有用吗？</p>
<p>在测试中，使用了<code>throughput-performance</code>这个配置。经过测试，配合相关参数的优化，最终服务器的的CPU使用率几乎达到满负荷。这证明我们的设置是有效的。</p>
<p>参考：</p>
<ul>
<li>安装及使用：<a href="https://computingforgeeks.com/optimize-linux-system-performance-with-tuned-adm/">https://computingforgeeks.com/optimize-linux-system-performance-with-tuned-adm/</a>。</li>
<li>创建个性化的tuned profile：<a href="https://www.tecmint.com/tuned-automatic-performance-tuning-of-centos-rhel-servers/">https://www.tecmint.com/tuned-automatic-performance-tuning-of-centos-rhel-servers/</a></li>
<li>在centos 7上创建自己的tuned profile：<a href="https://www.golinuxcloud.com/how-to-create-custom-tuned-profile-in-linux-rhel-centos-7/">https://www.golinuxcloud.com/how-to-create-custom-tuned-profile-in-linux-rhel-centos-7/</a></li>
</ul>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>上面已经说了如何优化，但是生产环境是不能随意改的，所以我们在alpha做下优化，看是否确实正确且有效。</p>
<h3 id="首先验证在缺省的sysctl-conf配置下系统性能"><a href="#首先验证在缺省的sysctl-conf配置下系统性能" class="headerlink" title="首先验证在缺省的sysctl.conf配置下系统性能"></a>首先验证在缺省的<code>sysctl.conf</code>配置下系统性能</h3><p>使用nginx下的index.html来验证，性能工具使用wrk。</p>
<p>测试结果：</p>
<ol>
<li>一开始吞吐量还比较大，系统TPS比较大，随着请求越来越多，连接错误越来越多，tps由一开始的接近1w下降到几百，性能急剧下降，错误主要是连接被拒绝</li>
<li>上述连接错误是因为系统参数设置太小，主要是<code>net.core.somaxconn</code>太小，这个参数太小导致系统同时建立的连接数被限制在128以内。下面是运行过程中统计的连接情况：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost lizhiqiang]<span class="comment"># netstat -n | awk &#x27;/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;&#x27;</span></span><br><span class="line">TIME_WAIT 13</span><br><span class="line">ESTABLISHED 128</span><br></pre></td></tr></table></figure>

<h3 id="验证使用新的sysctl-conf配置后系统性能"><a href="#验证使用新的sysctl-conf配置后系统性能" class="headerlink" title="验证使用新的sysctl.conf配置后系统性能"></a>验证使用新的sysctl.conf配置后系统性能</h3><p>使用下述附录所示的<code>sysctl.conf</code>配置以及上述内容提到的其他配置后，运行在一台8C16G的linux虚拟机上的NGINX web服务的性能可达到10w qps，CPU利用率几乎100%，这说明了优化措施的有效性。</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="sysctl-conf完整配置示例"><a href="#sysctl-conf完整配置示例" class="headerlink" title="sysctl.conf完整配置示例"></a>sysctl.conf完整配置示例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Max listen queue backlog</span><br><span class="line"># make sure to increase nginx backlog as well if changed</span><br><span class="line">net.core.somaxconn = 65535</span><br><span class="line"></span><br><span class="line"># 是指定所能接受SYN同步包的最大客户端数量。</span><br><span class="line"># Increase max half-open connections.</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 262144</span><br><span class="line"></span><br><span class="line"># 每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目。</span><br><span class="line"># Max number of packets that can be queued on interface input</span><br><span class="line"># If kernel is receiving packets faster than can be processed</span><br><span class="line"># this queue increases</span><br><span class="line">net.core.netdev_max_backlog = 262144</span><br><span class="line"></span><br><span class="line"># 允许系统打开的端口范围，扩大端口数</span><br><span class="line"># 可配成1024 65535进一步扩大可用范围</span><br><span class="line">net.ipv4.ip_local_port_range = 1024 65535</span><br><span class="line"></span><br><span class="line"># 在TIME_WAIT数量等于该值时，不会有新的产生，</span><br><span class="line"># 这个参数表示操作系统允许TIME_WAIT套接字数量的最大值，如果超过这个数字，TIME_WAIT套接字将立刻被清除并打印警告信息。该参数默认为65536(在centos7)，过多的TIME_WAIT套接字会使Web服务器变慢。注：主动关闭连接的服务端会产生TIME_WAIT状态的连接</span><br><span class="line"># max number of sockets allowed in TIME_WAIT</span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 6000</span><br><span class="line"></span><br><span class="line"># 是否启用timewait 快速回收。如果服务器身处NAT环境，tcp_timestamps为1，安全起见，要禁止</span><br><span class="line">net.ipv4.tcp_tw_recycle = 1</span><br><span class="line"></span><br><span class="line"># # 开启重用。允许将TIME-WAIT sockets 重新用于新的TCP 连接。</span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line"></span><br><span class="line">#这个参数表示内核套接字接受缓存区默认的大小。</span><br><span class="line">net.core.rmem_default = 6291456</span><br><span class="line"></span><br><span class="line">##这个参数表示内核套接字发送缓存区默认的大小。</span><br><span class="line">net.core.wmem_default = 6291456</span><br><span class="line"></span><br><span class="line">##这个参数表示内核套接字接受缓存区的最大大小。12MB</span><br><span class="line">net.core.rmem_max = 12582912</span><br><span class="line"></span><br><span class="line">##这个参数表示内核套接字发送缓存区的最大大小。12MB</span><br><span class="line">net.core.wmem_max = 12582912</span><br><span class="line"></span><br><span class="line"># 打开文件句柄数量</span><br><span class="line">fs.file-max = 1000000</span><br><span class="line"></span><br><span class="line"># 默认是1，对于负载均衡服务器来说必须设为1，此处设为0没有关系，可设可不设</span><br><span class="line">net.ipv4.ip_forward = 0</span><br><span class="line"></span><br><span class="line"># sysrq允许系统在任何时候响应用户按键操作，除非被锁定</span><br><span class="line"># 默认是16，表示启动sysrq命令，0表示完全禁用 sysrq</span><br><span class="line"># It is a ‘magical’ key combo you can hit which the kernel will respond to regardless of whatever else it is doing, unless it is completely locked up.</span><br><span class="line"># https://www.kernel.org/doc/html/latest/admin-guide/sysctl/kernel.html?highlight=kernel%20sysrq#sysrq</span><br><span class="line"># 是否设置无所谓</span><br><span class="line">kernel.sysrq = 0</span><br><span class="line"></span><br><span class="line">#IPC通信相关参数，建议可以增加</span><br><span class="line">#MSGMNB - Default maximum size in bytes of a message queue: 16384 bytes (on Linux, this limit can be read and modified via /proc/sys/kernel/msgmnb). The superuser can increase the size of a message queue beyond MSGMNB by a msgctl() system call.</span><br><span class="line">kernel.msgmnb = 65536</span><br><span class="line">#Maximum size for a message text: 8192 bytes (on Linux, this limit can be read and modified via /proc/sys/kernel/msgmax).</span><br><span class="line">kernel.msgmax = 65536</span><br><span class="line"></span><br><span class="line">#共享内存相关参数</span><br><span class="line">#Maximum size in bytes for a shared memory segment。实际是16GB物理内存，设成64GB，可以根据实际测试情况调整，但最小应该在4GB以上（在32位linux系统上最小是4GB）</span><br><span class="line">kernel.shmmax = 68719476736</span><br><span class="line"># shmall最少得是ceil(shmmax/PAGE_SIZE)，执行getconf PAGE_SIZE可得到PAGE_SIZE大小。centos7中是4096</span><br><span class="line">kernel.shmall = 4294967296</span><br><span class="line"></span><br><span class="line"># The first value tells the kernel the minimum receive/send buffer for each TCP connection,</span><br><span class="line"># and this buffer is always allocated to a TCP socket,</span><br><span class="line"># even under high pressure on the system. …</span><br><span class="line"># The second value specified tells the kernel the default receive/send buffer</span><br><span class="line"># allocated for each TCP socket. This value overrides the /proc/sys/net/core/rmem_default</span><br><span class="line"># value used by other protocols. … The third and last value specified</span><br><span class="line"># in this variable specifies the maximum receive/send buffer that can be allocated for a TCP socket.</span><br><span class="line"># Note: The kernel will auto tune these values between the min-max range</span><br><span class="line"># If for some reason you wanted to change this behavior, disable net.ipv4.tcp_moderate_rcvbuf</span><br><span class="line">#这个参数定义了TCP接受缓存（用于TCP接受滑动窗口）的最小值、默认值、最大值。</span><br><span class="line">#默认情况下这几个值是4096	16384	4194304</span><br><span class="line">net.ipv4.tcp_rmem = 10240 87380 12582912</span><br><span class="line">#这个参数定义了TCP发送缓存（用于TCP发送滑动窗口）的最小值、默认值、最大值。</span><br><span class="line">net.ipv4.tcp_wmem = 10240 87380 12582912</span><br><span class="line"></span><br><span class="line">#这个参数表示内核套接字发送缓存区默认的大小。默认是212992</span><br><span class="line">net.core.wmem_default = 8388608</span><br><span class="line">#这个参数表示内核套接字接受缓存区默认的大小。</span><br><span class="line">net.core.rmem_default = 8388608</span><br><span class="line">#这个参数表示内核套接字接受缓存区的最大大小。默认是212992</span><br><span class="line">net.core.rmem_max = 16777216</span><br><span class="line">#这个参数表示内核套接字发送缓存区的最大大小。</span><br><span class="line">net.core.wmem_max = 16777216</span><br><span class="line"></span><br><span class="line"># 系统中最多有多少个TCP 套接字不被关联到任何一个用户文件句柄上。如果超过这个数字，孤儿连接将即刻被复位并打印出警告信息。默认是65536</span><br><span class="line"># Increase max TCP orphans</span><br><span class="line"># These are sockets which have been closed and no longer have a file handle attached to them</span><br><span class="line">net.ipv4.tcp_max_orphans = 262144</span><br><span class="line"></span><br><span class="line"># 开启时就是同一个源IP来连接同一个目的端口的数据包时间戳必须是递增的，否则就丢弃。默认是打开的</span><br><span class="line">net.ipv4.tcp_timestamps = 0</span><br><span class="line"></span><br><span class="line"># Only retry creating TCP connections twice</span><br><span class="line"># Minimize the time it takes for a connection attempt to fail</span><br><span class="line"># 为了打开对端的连接，内核需要发送一个SYN，以确认收到上一个 SYN连接请求包。也就是所谓三次握手中的第二次握手。</span><br><span class="line"># 这个设置决定了内核放弃连接之前发送SYN+ACK 包的数量。有文章建议设为2个</span><br><span class="line">net.ipv4.tcp_synack_retries = 1</span><br><span class="line"># 对于一个新建连接，内核要发送多少个 SYN 连接请求才决定放弃。有文章建议设为2个</span><br><span class="line">net.ipv4.tcp_syn_retries = 1</span><br><span class="line"></span><br><span class="line"># Units are in page size (default page size is 4 kb)</span><br><span class="line"># These are global variables affecting total pages for TCP</span><br><span class="line"># sockets</span><br><span class="line"># 8388608 * 4 = 32 GB</span><br><span class="line">#  low pressure high</span><br><span class="line">#  When mem allocated by TCP exceeds “pressure”, kernel will put pressure on TCP memory</span><br><span class="line">#  We set all these values high to basically prevent any mem pressure from ever occurring</span><br><span class="line">#  on our TCP sockets</span><br><span class="line">#默认是378357	504477	756714（单位页大小，即4KB），对应的大小大约是1.5GB 1.9GB 2.9GB</span><br><span class="line"># 提高配置避免出现内存分配压力（根据实际内存大小可以计算一下）</span><br><span class="line">net.ipv4.tcp_mem = 94500000 915000000 927000000</span><br><span class="line"></span><br><span class="line">## timeout状态时间 </span><br><span class="line">#表示如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间。默认是60s，可以设置小一些</span><br><span class="line">net.ipv4.tcp_fin_timeout = 15</span><br><span class="line"></span><br><span class="line">#这个参数表示当keepalive启用时，TCP发送keepalive消息的频度。默认是2小时(7200秒)，若将其设置的小一些，可以更快地清理无效的连接。</span><br><span class="line">#How often TCP sends out keepalive messages when keepalive is enabled. Default: 2hours.</span><br><span class="line">net.ipv4.tcp_keepalive_time = 30</span><br></pre></td></tr></table></figure>

<h3 id="探索系统配置工具Cockpit-Web"><a href="#探索系统配置工具Cockpit-Web" class="headerlink" title="探索系统配置工具Cockpit Web"></a>探索系统配置工具Cockpit Web</h3><p>Cockpit Web是一个查看系统配置的web工具。在<a href="https://computingforgeeks.com/optimize-linux-system-performance-with-tuned-adm/">https://computingforgeeks.com/optimize-linux-system-performance-with-tuned-adm/</a>的推荐下，搜索了工具怎么使用。</p>
<p>我的观点是，如果有可视化界面可以一览式查看系统的配置，可以节省很多精力。因为它可以让我们把精力放在最重要或最值得关注的点上面。另外，如果工具可以让我了解有哪些可以用的最优设置，然后就可以和之前摸索工的、自己修改过的配置对比，了解自己的设置是否是正确的，两相印证。</p>
<p>安装操作见<a href="https://www.hangge.com/blog/cache/detail_3024.html">https://www.hangge.com/blog/cache/detail_3024.html</a>。cockpit web页面的访问地址是<a href="https://ip:9090/system">https://ip:9090/system</a>。</p>
<p>总结一下必要的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#启用 epel-release</span></span><br><span class="line">yum install epel-release</span><br><span class="line"><span class="comment">#安装 dnf：entOS 8 自带了 dnf可以不装</span></span><br><span class="line">yum install dnf</span><br><span class="line"><span class="comment">#安装cockpit</span></span><br><span class="line">dnf install cockpit cockpit-machines</span><br><span class="line"><span class="comment">#启动cockpit服务或设置自动启动服务</span></span><br><span class="line">systemctl start cockpit.socket</span><br><span class="line">systemctl <span class="built_in">enable</span> cockpit.socket</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>关于<code>/proc/sys/net/</code>的说明：<a href="https://www.kernel.org/doc/html/latest/admin-guide/sysctl/net.html?highlight=netdev_max_backlog">https://www.kernel.org/doc/html/latest/admin-guide/sysctl/net.html?highlight=netdev_max_backlog</a></li>
<li>linux ipc and limits: <a href="https://tech.vys.in/2007/08/ipc-limits-in-linux.html">https://tech.vys.in/2007/08/ipc-limits-in-linux.html</a></li>
</ul>
]]></content>
      <categories>
        <category>centos</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>linux</tag>
        <tag>performance</tag>
      </tags>
  </entry>
  <entry>
    <title>JMeter调优</title>
    <url>/2021/10/07/JMeter%E8%B0%83%E4%BC%98/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>可能多少对于JMeter存在这样一些刻板印象：</p>
<ul>
<li>JMeter 消耗大量内存…</li>
<li>JMeter 产生 OutOfMemory 错误…</li>
<li>JMeter 消耗大量 CPU…</li>
<li>其他</li>
</ul>
<p>那么，是否还有调优的余地？可能指望它像一些轻量级工具那样轻巧是有点难了，比如ab，比如wrk。但是如果能够将jmeter优化成只比这些工具多消耗一些不多的资源，那么多个jmeter协同工作的威力就可以充分发挥出来了。</p>
<h2 id="调优清单"><a href="#调优清单" class="headerlink" title="调优清单"></a>调优清单</h2><p>下面是一些调优技巧清单，还有很多其他更细致的优化手段没有列出来：</p>
<ol>
<li>从命令行运行 ：避免在负载测试期间使用 JMeter UI，它会占用大量内存</li>
<li>避免使用监听器 ：避免使用图形或结果表等 UI 监听组件</li>
<li>增加 JVM 堆空间 ：以更大的内存量启动 JMeter，如下例所示：<code>JVM_ARGS=&quot;-Xms512m -Xmx512m&quot; jmeter.sh1</code>,考虑将每个 JVM 的内存增加到 8GB，在同一台机器上至少有 8GB 的​​可用 RAM。</li>
<li>使用最新的 JMeter 版本 ：JMeter 会定期随着新版本的发布而改进。 坚持使用最新版本以获得最新的改进。</li>
<li>使用 Regexp 变量提取器从响应中提取数据 ：但永远不要使用 的 Body（未转义） 解析整个响应 DOM 树 选项。 避免使用 Json、Xpath 和任何其他花哨的后处理器。 这些会消耗大量内存。</li>
<li>避免从大型响应中提取数据 ：整个响应都保存在内存中，从而显着增加了内存消耗。 只提取必要的数据，而不是更多。</li>
<li>每台机器模拟合理数量的线程 每台机器 ：避免 模拟超过 1000 个用户。 通常，瓶颈是网络连接（在最佳云实例上为 1Gbps）。 JVM 不能很好地处理超过 2000 个线程。</li>
<li>在普通机器上分配负载 ：避免使用少数具有特殊硬件（例如 16 核 / 128GB RAM）的机器，坚持使用普通机器（4 核，16GB RAM）并使用更多机器代替。 JMeter 无法利用这么多 RAM，因为 JVM 不能很好地处理大于 16GB 的 Xmx。</li>
<li>明智地使用断言 ：断言会增加内存使用量。 使用几个是合理的，但避免使用太多，因为它会显着增加内存使用量。 此外，避免对大型服务器响应（大于 1MB）进行断言。</li>
<li>运行后生成报告 后， ：负载测试完成 使用输出的 JTL 文件创建报告。 构建报告需要大量的 CPU 和内存资源。</li>
<li>在大多数情况下，网络是瓶颈 ：这意味着最好拥有具有良好网络连接的中型机器，而不是具有低网络能力的强大机器。</li>
<li>避免 BeanShell 脚本 ：这些脚本比嵌入在 JSR223 采样器中的 Groovy 脚本使用更多的 CPU 来执行。 如果你需要运行自定义逻辑，请坚持使用 JSR223 采样器。</li>
<li>不要在分布式模式下运行 ：分布式模式适用于 20-30 台机器，如果运气好的话，最多可以使用 40-50 台机器。 这会将你限制为 20-50k 并发用户。 相反，通过在开始测试之前发送 JMX 并在完成后检索 JTL 文件来独立运行每个 JMeter 实例。 JMeter 用于在负载生成器和控制器之间进行通信的 RMI 协议效率不高。</li>
<li>在 JTL 中仅存储指标而不是请求/响应 在 JTL 中 ：避免 存储请求、响应、响应头，因为它会使用大量资源。 当然，在发生故障时让服务器响应很好，但是在运行大负载测试时就不合理了。</li>
<li>作为最后的手段，调整 JVM ：垃圾收集器 (-XX:+UseConcMarkSweepGC)、服务器 JVM (-server) 等设置可以通过编辑 JMeter 启动程序脚本在 JVM_ARGS 中设置。 但是，一旦你尝试从 JVM 中获取最后的汁液，JMeter 的行为可能会出乎意料。 通常，优化场景效果更好。</li>
<li>优化正则表达式 正则表达式 ：写得不好的 会影响 CPU 性能。 尝试查看 正则表达式指南 ，也许你的正则表达式提取器表达式可以缩小。</li>
<li>使用带有物理硬件的专用负载生成器 ：避免使用虚拟机，因为运行这些的机器与其他虚拟机共享资源（尤其是网络）。 专用物理机是确保最大稳定性的最佳选择。</li>
<li>逐渐增加负载 ：缓慢增加模拟负载以避免过快地压倒测试的服务器。 通常，较小的负载测试是针对服务器运行的，以在对其进行测试 进行 预热 之前对其 。</li>
<li>避免功能模式 ：这种运行模式不适合负载测试，因为它在 JTL 结果文件中存储了更多信息。</li>
<li>将结果存储在 CSV JTL 而不是 XML 中 ：XML 需要 JMeter 在磁盘上写入更多 CPU。 此外，它比 CSV 格式更冗长，因此需要更多的磁盘空间。</li>
<li>在测试期间监控 JMeter 日志 ：这可以通过在负载测试期间使用 等工具发送 JMeter 日志来实现 Elastic Stack 。 这样，你可以密切关注每个负载生成器在负载测试期间的行为。</li>
<li>使用测试元素的命名约定 ：这样，你可以快速将结果与业务事务和请求相关联。 使用唯一的名称来防止结果文件中不同测试元素的结果混合。</li>
<li>避免过于复杂的场景 ：你模拟的负载越多，模拟的场景就越不复杂。 复杂的场景难以理解，使得结果更难以解释。 KISS （Keep It Simple And Stupid）是最好的方法。</li>
<li>使用 Oracle JVM 而不是 OpenJDK ：Oracle JVM 最适合运行高要求 JVM 应用程序（如 JMeter）。 Oracle JVM 在压力下通常更稳定。</li>
<li>在测试期间监控负载生成器 ：密切关注每个负载生成器的 CPU/内存/网络使用情况。 有时，由于负载生成器的大小不正确，测试可能会变得异常。 通过监控它们，你可以防止结果被误解：测试可能因为负载生成器不堪重负而出错。</li>
<li>监控测试服务器 ：发现性能瓶颈的关键是监控运行负载测试的测试后端服务器。 你将能够将性能下降与服务器端问题相关联。 这样，你可以更快地解决后端方面的性能问题。 工具 Perfmon 之 推荐使用 类的 。</li>
<li>首先在内部运行负载测试 ：这听起来可能很奇怪，但是负载生成器离测试的服务器越近，影响性能测试结果的因素就越少。 本地负载测试可避免 Internet 连接问题，并可使用大型内部网络（通常为 1 到 10 Gbps）。 一旦服务器在内部测试中表现良好，云测试就可以揭示互联网网络问题。 这样，你可以将服务器问题与网络问题分开。</li>
<li>避免对第三方服务进行负载测试 ：删除对第三方服务（如 Google、Gmail、Facebook、雅虎、Reddit 等）的任何请求，以避免对不属于你自己的服务进行负载测试。 他们可能会禁止你这样做（被视为 DDoS 攻击），并且可能会以错误的方式影响测试结果。</li>
<li>快速响应时间并不总是意味着快速服务器 ：还要检查错误计数。 服务器通常在提供错误页面方面非常快，而在提供有意义的网页时要慢得多。 当你有大量错误时，请确保你不会被出色的响应时间所欺骗。</li>
<li>扩展 JMeter 既困难又耗时 ：虽然运行分布式 JMeter 测试自己似乎很有趣，因为云机器如此便宜，但真正的价值并不存在。 自动发送 JMX、发送 CSV 文件、启动 JMeter 实例、监控一切，然后收集结果并分析它们需要时间。 你的时间也有成本，考虑到这一点。</li>
<li>避免通过代理进行负载测试 ：否则你最终也会对代理服务器进行负载测试。 根据负载，代理可能会在你的服务器之前失败。 避免任何可能影响测试结果的中间网络设备或服务器。</li>
<li>http采样器使用合适的实现</li>
</ol>
<h2 id="具体调优"><a href="#具体调优" class="headerlink" title="具体调优"></a>具体调优</h2><p>包括：</p>
<ul>
<li>最大堆大小：我们每台机器内存有16GB，可以分配12GB给jmeter，因此把堆大小往上调大为：<code>heap=-Xms1024m -Xmx12288m</code></li>
<li>假设每个线程需要1MB内存，那么1k线程需要1GB内存，理论上我们设置最大内存为</li>
<li>内存分配率：</li>
</ul>
<h2 id="接着对测试脚本进行优化，确保"><a href="#接着对测试脚本进行优化，确保" class="headerlink" title="接着对测试脚本进行优化，确保"></a>接着对测试脚本进行优化，确保</h2><p>如果http sampler采用httpclient4，经过测试发现性能更高（高25%左右），虽然cpu使用率也更高一些。</p>
<p>采用另外一种GC的方法ConcMarkSweep，下面的命令有待验证：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GC_ALGO:=<span class="string">&quot;-XX:+UseConcMarkSweepGC&quot;</span> JVM_ARGS=<span class="string">&quot;-Dcom.sun.management.jmxremote.port=1098 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Xms4g -Xmx12g -XX:NewSize=128m -XX:MaxNewSize=512m -agentlib:jprofilerti=port=8849,nowait -Xbootclasspath/a:/opt/jprofiler12/bin/agent.jar&quot;</span> ./jmeter -Dserver_port=<span class="variable">$&#123;SERVER_PORT:-1099&#125;</span> -s -j jmeter-server.log <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>jmeter优化技巧 <a href="https://octoperf.com/blog/2017/10/12/optimize-jmeter-for-large-scale-tests/#tips-and-tricks">https://octoperf.com/blog/2017/10/12/optimize-jmeter-for-large-scale-tests/#tips-and-tricks</a></li>
<li>解决jmeter内存问题 <a href="https://octoperf.com/blog/2017/10/17/solve-jmeter-out-of-memory-issues/#use-the-right-script-engine">https://octoperf.com/blog/2017/10/17/solve-jmeter-out-of-memory-issues/#use-the-right-script-engine</a></li>
<li><a href="https://octoperf.com/blog/2017/10/12/optimize-jmeter-for-large-scale-tests/#cloud-instances">https://octoperf.com/blog/2017/10/12/optimize-jmeter-for-large-scale-tests/#cloud-instances</a></li>
<li>jmeter性能调优 <a href="https://www.ubik-ingenierie.com/blog/jmeter_performance_tuning_tips/">https://www.ubik-ingenierie.com/blog/jmeter_performance_tuning_tips/</a></li>
<li>调优JVM： <a href="https://help.aliyun.com/document_detail/148851.html">https://help.aliyun.com/document_detail/148851.html</a></li>
<li>最佳实践 <a href="http://jmeter.apache.org/usermanual/best-practices.html">http://jmeter.apache.org/usermanual/best-practices.html</a></li>
<li>计算单机所能支持的线程数 <a href="https://sarkershantonu.github.io/2015/04/16/user-threads-jmeter-supports/">https://sarkershantonu.github.io/2015/04/16/user-threads-jmeter-supports/</a></li>
</ul>
]]></content>
      <categories>
        <category>jmeter</category>
      </categories>
      <tags>
        <tag>jmeter</tag>
        <tag>performance-tune</tag>
      </tags>
  </entry>
  <entry>
    <title>MAT分析JAVA进程内存</title>
    <url>/2021/12/11/MAT%E5%88%86%E6%9E%90JAVA%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<h1 id="MAT分析JAVA进程内存"><a href="#MAT分析JAVA进程内存" class="headerlink" title="MAT分析JAVA进程内存"></a>MAT分析JAVA进程内存</h1><h2 id="jstatd-jvisualvm监视内存使用"><a href="#jstatd-jvisualvm监视内存使用" class="headerlink" title="jstatd + jvisualvm监视内存使用"></a>jstatd + jvisualvm监视内存使用</h2><p>一般情况下，如果服务端开了JMX端口，那么可以用jvisualvm对接堆jmx端口进行监控。但有时服务进程可能没有开jmx端口，那么就可以借助于jstatd进程来完成实现监控了。jstatd的作用是获取服务进程的运行信息，然后jvisualvm通过jmx端口（jstatd会启动jmx端口）获取远端服务进程的内存使用情况。</p>
<h3 id="在目标服务器启动jstatd"><a href="#在目标服务器启动jstatd" class="headerlink" title="在目标服务器启动jstatd"></a>在目标服务器启动jstatd</h3><p>在任意目录下创建一个文件，只要以.policy结尾，这里假设路径是/opt/jstad-config/jstatd.all.policy:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">grant codebase <span class="string">&quot;file:$&#123;java.home&#125;/../lib/tools.jar&quot;</span>&#123;</span><br><span class="line">    permission java.security.AllPermission;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以后端进程形式启动jstatd,默认开启jmx端口1099:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jstatd -J-Djava.security.policy=/opt/jstad-config/jstatd.all.policy -J-Djava.rmi.server.hostname=xx.yy.zz.aa &amp;</span><br></pre></td></tr></table></figure>

<p>然后可远程查看java进程（语法<code>jps xx.yy.zz.aa</code>）或使用jvisualvm连接到该服务器上查看需要监控的进程。</p>
<p>参考：<a href="https://blog.csdn.net/u013887008/article/details/84746610">https://blog.csdn.net/u013887008/article/details/84746610</a></p>
<h3 id="在jvisualvm监控远程java进程"><a href="#在jvisualvm监控远程java进程" class="headerlink" title="在jvisualvm监控远程java进程"></a>在jvisualvm监控远程java进程</h3><p>打开jvisualvm。</p>
<p>在左侧remote下添加远程服务器，hostname就按照上面启动jstatd进程时指定的hostname填写。</p>
<p>添加完成后，选中远程服务器节点，右键，选择“add jstatd connection“。填写jstatd使用的jmx端口及刷新间隔。</p>
<p>添加连接：</p>
<p><img src="/images/mat/mat-add-jstatd-conn.png" alt="add jstatd conn"></p>
<p>设置连接：</p>
<p><img src="/images/mat/mat-set-jstatd-conn.png" alt="add jstatd conn"></p>
<p>然后，可以在jvisualvm实时监控远端服务内存情况了。</p>
<p>说明：这种方法对远端服务器的资源消耗有多少，具体没测试过。可能需要注意一下。</p>
<h2 id="深度分析java代码"><a href="#深度分析java代码" class="headerlink" title="深度分析java代码"></a>深度分析java代码</h2><h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><p>Entity类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ajupiter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Entity</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; arrayList;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Entity</span><span class="params">(String a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        name = a;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">100</span>;</span><br><span class="line">        arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            arrayList.add(<span class="string">&quot;thisi is no. &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        age = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>产生OOME错误的类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ajupiter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试产生OOM错误，实际最大运行时间约30s，但一般会因为产生OOM错误提前结束</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">oom</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">30000</span>;</span><br><span class="line">        Object[] array = <span class="keyword">new</span> Object[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            String d = <span class="keyword">new</span> Date().toString();</span><br><span class="line">            Entity p = <span class="keyword">new</span> Entity(d, i);</span><br><span class="line">            Map&lt;Integer, Entity&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            map.put(i, p);</span><br><span class="line">            array[i] = p;</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ajupiter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OOMProducer oomProducer = <span class="keyword">new</span> OOMProducer();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oomProducer.oom();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;出现错误&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="运行程序使产生OOME错误"><a href="#运行程序使产生OOME错误" class="headerlink" title="运行程序使产生OOME错误"></a>运行程序使产生OOME错误</h3><p>使用javac 编译代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">javac -d target src/**/*.java</span><br></pre></td></tr></table></figure>

<p>然后cd到target目录，执行程序。因为我指定了最大堆大小为10M，所以程序运行到一段时间后报错，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  target java -Xmx10m -Xms10m -XX:+HeapDumpOnOutOfMemoryError com.ajupiter.Main</span><br><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">Dumping heap to java_pid33714.hprof ...</span><br><span class="line">Heap dump file created [14343715 bytes <span class="keyword">in</span> 0.080 secs]</span><br><span class="line">Exception <span class="keyword">in</span> thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">        at java.base/jdk.internal.misc.Unsafe.allocateUninitializedArray(Unsafe.java:1271)</span><br><span class="line">        at java.base/java.lang.invoke.StringConcatFactory<span class="variable">$MethodHandleInlineCopyStrategy</span>.newArray(StringConcatFactory.java:1633)</span><br><span class="line">        at java.base/java.lang.invoke.DirectMethodHandle<span class="variable">$Holder</span>.invokeStatic(DirectMethodHandle<span class="variable">$Holder</span>)</span><br><span class="line">        at java.base/java.lang.invoke.LambdaForm<span class="variable">$MH</span>/0x0000000800063c40.invoke(LambdaForm<span class="variable">$MH</span>)</span><br><span class="line">        at java.base/java.lang.invoke.Invokers<span class="variable">$Holder</span>.linkToTargetMethod(Invokers<span class="variable">$Holder</span>)</span><br><span class="line">        at com.ajupiter.Entity.&lt;init&gt;(Entity.java:16)</span><br><span class="line">        at com.ajupiter.OOMProducer.oom(OOMProducer.java:15)</span><br><span class="line">        at com.ajupiter.Main.main(Main.java:9)</span><br></pre></td></tr></table></figure>

<p>如果是在IDEA中运行，也可以在菜单Run下的Run/Debug Configurations对话框，添加VM选项<code>-Xmx10m -Xms10m -XX:+HeapDumpOnOutOfMemoryError</code>。</p>
<p><img src="/images/mat/mat-add-vm-options.png" alt="add vm option"></p>
<p>在运行过程中，可以借助于VisualVM观察该程序实际使用的内存情况。</p>
<h3 id="使用MAT分析"><a href="#使用MAT分析" class="headerlink" title="使用MAT分析"></a>使用MAT分析</h3><p>对上述产生的java_pid33714.hprof文件，使用MAT（Eclipse Memory Analyzer Tool）分析。</p>
<p>显示了具体的内存泄漏情况。</p>
<p><img src="/images/mat/mat-analyze.png" alt="mat analyze"></p>
<p>有一篇文章对内存泄漏有详细分析，个人觉得写得还是很不错的。见<a href="https://blog.csdn.net/rachel_luo/article/details/8992461">https://blog.csdn.net/rachel_luo/article/details/8992461</a>。上面的代码案例也基本参考了这篇博文。</p>
<p>提示：如果产生的dump文件（.hprof)比较大，记得修改MAT的最大堆大小。</p>
]]></content>
  </entry>
  <entry>
    <title>Maven常用仓库及配置多仓库</title>
    <url>/2021/09/09/Maven%E5%B8%B8%E7%94%A8%E4%BB%93%E5%BA%93%E5%8F%8A%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<h2 id="常用repo列表"><a href="#常用repo列表" class="headerlink" title="常用repo列表"></a>常用repo列表</h2><p>首先介绍一个搜索jar包的常用网址：<a href="http://mvnrepository.com/">http://mvnrepository.com/</a>。</p>
<p>如果想知道哪些库比较流行，可以在 <a href="https://mvnrepository.com/repos/central">https://mvnrepository.com/repos/central</a> 看到。截止2021年9月，最流行的仍然是central这个库。</p>
<h3 id="center"><a href="#center" class="headerlink" title="center"></a>center</h3><p>repo配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- This should be at top, it makes maven try the central repo</span></span><br><span class="line"><span class="comment">        first and then others and hence faster dep resolution --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Maven Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo1.maven.org/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="jcenter"><a href="#jcenter" class="headerlink" title="jcenter"></a>jcenter</h3><p>repo配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>jcenter<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://jcenter.bintray.com<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="spring-plugins"><a href="#spring-plugins" class="headerlink" title="spring plugins"></a>spring plugins</h3><p>url:<a href="https://repo.spring.io/plugins-release/">https://repo.spring.io/plugins-release/</a></p>
<h3 id="sonartype"><a href="#sonartype" class="headerlink" title="sonartype"></a>sonartype</h3><p>排名靠前。大名鼎鼎的nexus就是sonartype公司的产品。</p>
<p>url：<a href="https://oss.sonatype.org/content/repositories/releases/">https://oss.sonatype.org/content/repositories/releases/</a></p>
<h3 id="spring的几个仓库"><a href="#spring的几个仓库" class="headerlink" title="spring的几个仓库"></a>spring的几个仓库</h3><p>repo配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>libs-milestone<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.spring.io/libs-milestone/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>libs-release<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.spring.io/libs-release/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="aliyun的仓库"><a href="#aliyun的仓库" class="headerlink" title="aliyun的仓库"></a>aliyun的仓库</h3><p>aliyun的仓库搭配上面几个库一起使用，就比较全面了，不大会出现找不到jar的问题。可以把aliyun的放到最前面，如果aliyun有就不会找后面的仓库，如果没有再去其他仓库找，这样可以保证速度最快。</p>
<p>repo配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">snapshots</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>ali-central<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/central<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>alispringplugin<span class="tag">&lt;/<span class="name">id</span>&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>spring-plugin<span class="tag">&lt;/<span class="name">name</span>&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/spring-plugin<span class="tag">&lt;/<span class="name">url</span>&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span>    </span><br><span class="line">      <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="maven配置多仓库"><a href="#maven配置多仓库" class="headerlink" title="maven配置多仓库"></a>maven配置多仓库</h2><p>经过上面的介绍，相信大家对于应该配置哪些仓库基本有所了解了。当然很多都是经验之谈，基于仓库的流行程度和速度快慢来选择的，没有详细介绍为什么要配置这些仓库，可能在遇到一些特殊的依赖包的时候，恰巧在上述仓库中都没有。那么你就需要把那个包的仓库的配置加到全局的settings.xml中了。</p>
<p>完整的settingx.xml配置如下，可以复制替代你原来默认的配置了（建议原来的备份一份）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.1.0 http://maven.apache.org/xsd/settings-1.1.0.xsd&quot;</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.1.0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这个地方一般用于记录私服的用户密码之类信息，公库一般不需要这个配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>search-aliyun-first<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- aliyun repo--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">snapshots</span> /&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">id</span>&gt;</span>central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">name</span>&gt;</span>ali-central<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/central<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">id</span>&gt;</span>alispringplugin<span class="tag">&lt;/<span class="name">id</span>&gt;</span>    </span><br><span class="line">          <span class="tag">&lt;<span class="name">name</span>&gt;</span>spring-plugin<span class="tag">&lt;/<span class="name">name</span>&gt;</span>    </span><br><span class="line">          <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span>  </span><br><span class="line">          <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/spring-plugin<span class="tag">&lt;/<span class="name">url</span>&gt;</span>    </span><br><span class="line">          <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span>    </span><br><span class="line">              <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span>    </span><br><span class="line">          <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- maven central--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- This should be at top, it makes maven try the central repo</span></span><br><span class="line"><span class="comment">                first and then others and hence faster dep resolution --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Maven Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo1.maven.org/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- jcenter repo--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>jcenter<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://jcenter.bintray.com<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- spring repo--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>libs-milestone<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.spring.io/libs-milestone/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>libs-release<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.spring.io/libs-release/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- sonartype --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>sonartype-release<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://oss.sonatype.org/content/repositories/releases/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">snapshots</span> /&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">name</span>&gt;</span>releases<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/releases<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">snapshots</span> /&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">id</span>&gt;</span>spring-plugins-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">name</span>&gt;</span>releases<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.spring.io/plugins-release<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">activeProfiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activeProfile</span>&gt;</span>search-aliyun-first<span class="tag">&lt;/<span class="name">activeProfile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">activeProfiles</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因为这些配置很难记住，所以记录了一下。希望有所帮助。</p>
]]></content>
      <categories>
        <category>maven</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>maven</tag>
        <tag>build</tag>
        <tag>config</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/08/26/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<span id="more"></span>

<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>helloworld</category>
      </categories>
      <tags>
        <tag>helloworld</tag>
      </tags>
  </entry>
  <entry>
    <title>使用JMeter5测试PostgreSQL数据库</title>
    <url>/2021/08/29/%E4%BD%BF%E7%94%A8JMeter5%E6%B5%8B%E8%AF%95PostgreSQL%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<p>在本节中，我们使用“JDBC请求”取样器组件来测试PostgreSQL数据库服务器。其他需使用的组件包括 线程组、 JDBC请求、摘要报告。对于MySQL或其他可以通过JDBC驱动连接的数据库，方法是类似的。</p>
<h2 id="准备测试环境"><a href="#准备测试环境" class="headerlink" title="准备测试环境"></a>准备测试环境</h2><p>本示例中JMeter与PostgreSQL运行在同一台机器，使用Java 11，PostgreSQL版本是13.4。</p>
<p>（1）准备数据库</p>
<p>首先需要安装PostgreSQL数据库（后面简称PG），请参考官方安装说明[ pg下载地址：<a href="https://www.postgresql.org/download/">https://www.postgresql.org/download/</a> ]，选择相符的操作系统，下载和安装PG。完成安装后，我们在PostgreSQL中创建数据库，并在该库下创建数据表以及创建相关用户。</p>
<p>本示例中创建数据库为“exampledb”，表名称为“user_tbl”。下表为相关sql命令。</p>
<p>代码片段 0-1 在PostgreSQL数据库上创建用户和数据表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#使用postgres用户在pg命令行上执行下述命令</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> dbuser2 <span class="keyword">WITH</span> PASSWORD <span class="string">&#x27;password&#x27;</span>;</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE test OWNER dbuser ENCODING utf8;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> DATABASE test <span class="keyword">to</span> dbuser;</span><br><span class="line">#然后使用新创建的用户dbuser登录pg后执行下述命令插入记录</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user_tbl(name <span class="type">VARCHAR</span>(<span class="number">20</span>), signup_date <span class="type">DATE</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_tbl(name, signup_date) <span class="keyword">VALUES</span>(<span class="string">&#x27;john&#x27;</span>, <span class="string">&#x27;2020-10-01&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>（2）安装数据库驱动</p>
<p>JMeter需要通过数据库驱动程序连接PostgreSQL数据库服务器，因此要将相关驱动文件复制到 JMeter安装目录下的 ./lib目录，并重启JMeter。JMeter从lib和lib/ext目录加载jar，更多详细信息请参阅JMeter的类路径。我们使用postgresql-42.2.23.jar[ 下载地址：<a href="https://jdbc.postgresql.org/download.html">https://jdbc.postgresql.org/download.html</a> ]作为访问PostgreSQL数据库的驱动持续。</p>
<h2 id="添加JDBC请求组件"><a href="#添加JDBC请求组件" class="headerlink" title="添加JDBC请求组件"></a>添加JDBC请求组件</h2><p>此处略过如何添加线程组以及设置用户数，参考之前的操作步骤即可。现在我们要在测试计划中添加执行JDBC Request的JMeter组件，即“JDBC请求”取样器。<br>首先需要配置JDBC连接属性。选择“线程组”，单击鼠标右键，然后选择 添加  →  配置元件 →  JDBC Connection Configuration 。配置该元件属性，如下图所示。</p>
<p>图 3-5-2-1 jdbc connection设置<br><img src="/images/jmeter5/jdbc/jdbc%20connection.png" alt="jdbc connection"></p>
<p>需要设置的字段包括：</p>
<ul>
<li>连接池变量名称（Variable name for created pool）：JDBC取样器使用它来识别相关配置，可以是任何字符串。本示例设为postgresql。</li>
<li>数据库地址（Database URL）：jdbc:postgresql://localhost/exampledb</li>
<li>JDBC 驱动类（JDBC Driver class）：org.postgresql.Driver</li>
<li>用户名（Username）：数据库的用户名。本示例中，此处为dbuser2。</li>
<li>密码（Password）：用户名的密码。本示例中，用户dbuser2的密码是password。</li>
<li>其他字段可以使用默认值。</li>
<li>Validation query字段：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Validation Query：这个有好多资料里都没说到，validationQuery must be an SQL SELECT statement, that returns at least one row。不同的数据库，所选择的Validation Query是不同的，经过外国友人的测试，具体可参照以下（postgresql选select 1）：</span><br><span class="line">hsqldb - select 1 from INFORMATION_SCHEMA.SYSTEM_USERS</span><br><span class="line">Oracle - select 1 from dual</span><br><span class="line">DB2 - select 1 from sysibm.sysdummy1</span><br><span class="line">mysql - select 1</span><br><span class="line">microsoft SQL Server - select 1 (tested on SQL-Server 9.0, 10.5 [2008])</span><br><span class="line">postgresql - select 1</span><br><span class="line">ingres - select 1</span><br><span class="line">derby - values 1</span><br><span class="line">H2 - select 1</span><br><span class="line">Firebird - select 1 from rdb$database</span><br></pre></td></tr></table></figure>

<p>接着，添加JDBC请求取样器。再次选择 JDBC 用户元素，单击鼠标右键，在弹出菜单选择 添加  →  取样器  →  JDBC Request 。然后，左键选择这个新元素并修改相关配置。</p>
<p>在我们的测试计划中，包括三个 JDBC Request取样器。第一个取样器向PostgreSQL数据库增加一行记录，第二个取样器查询记录，第三取样器清理第一个取样器插入的记录。JMeter 将按顺序将请求发送到服务器。具体配置如下。</p>
<p>图 0-1 第一个JDBC请求取样器即执行增加记录操作的取样器:<br><img src="/images/jmeter5/jdbc/jdbc%20insert.png" alt="jdbc connection"></p>
<p>上述为第一个请求配置面板，属性按如下设置编辑：</p>
<ul>
<li>将名称更改为“jdbc add”。</li>
<li>连接池变量名称：“ postgresql”（与JDBC Connection Configuration即JDBC连接配置中的相同）</li>
<li>设置查询类型（Query Type）为“Update Statement”</li>
<li>SQL 查询字符串</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_tbl(name, signup_date) <span class="keyword">VALUES</span>(<span class="string">&#x27;mike&#x27;</span>, <span class="string">&#x27;2020-10-01&#x27;</span>);</span><br><span class="line"><span class="comment">--其中查询字符串中可以使用JMeter变量或?，如：</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_tbl(name, signup_date) <span class="keyword">VALUES</span>(<span class="string">&#x27;$&#123;name&#125;&#x27;</span>, <span class="string">&#x27;2020-10-01&#x27;</span>)</span><br><span class="line"><span class="comment">--其中name为用户定义的变量。</span></span><br><span class="line"><span class="comment">--或者：</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_tbl(name, signup_date) <span class="keyword">VALUES</span>(?, <span class="string">&#x27;2020-10-01&#x27;</span>)</span><br><span class="line"><span class="comment">--目前暂时不能使用占位符，比如VALUES(?)这样。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在parameter values传入相关参数，在parameter types设置参数类型，均以逗号分隔。</li>
</ul>
<p>第二个用于查询的JDBC Request取样器如下。<br><img src="/images/jmeter5/jdbc/jdbc%20query.png" alt="jdbc add"></p>
<p>第三个JDBC Request取样器用于清理之前插入的数据，配置如下。<br><img src="/images/jmeter5/jdbc/jdbc%20delete.png" alt="jdbc add"></p>
<h3 id="执行和查看结果"><a href="#执行和查看结果" class="headerlink" title="执行和查看结果"></a>执行和查看结果</h3><p>在执行测试时，JMeter 使用控制面板中指定的配置创建数据库连接池。该连接池在 “JDBC Request ”中的“Variable Name of Pool declared in JDBC Connection Configuration”字段中引用。可以使用多个不同的 JDBC 配置元素，但它们必须具有唯一的名称，否则定义在后面配置将覆盖前面定义的配置。每个 JDBC Request都必须引用一个 JDBC 配置池，多个 JDBC Request可以引用同一个池。</p>
<p>在计划中，可以添加监听器来查看/存储测试结果。</p>
]]></content>
      <categories>
        <category>jmeter</category>
      </categories>
      <tags>
        <tag>JMeter</tag>
        <tag>JMeter5</tag>
        <tag>JDBC</tag>
        <tag>Database</tag>
        <tag>Test</tag>
      </tags>
  </entry>
  <entry>
    <title>使用pyecharts绘制系统依赖关系图</title>
    <url>/2021/09/05/%E4%BD%BF%E7%94%A8pyecharts%E7%BB%98%E5%88%B6%E7%B3%BB%E7%BB%9F%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>近期梳理了公司内部系统之间的数据关系，得到了多个excel格式的统计文件，每个文件包含了该系统自身数据清单、依赖的其他系统的数据清单、对其他系统供应的数据清单。<br>各系统之间依赖关系复杂，所以我想使用一些绘图工具，以可视化图形图表的形式展现这些系统之间的数据关系，给观众形成一种非常直观的印象。</p>
<p>一般情况下，应该是有类似于调用链跟踪等工具，比如Java技术栈使用Skywalking或美团CAT等工具，做到调用级别上的跟踪和相互关系的可视化展示。<br>这种情况下，也许不需要再编写程序来绘制依赖关系了。这两种工具可以很详细的绘制组件或服务之间的调用关系。</p>
<p>不过，本文介绍如何绘制粒度稍微粗一些的关系图，没有细化到具体某个接口调用。主要的工具是pyecharts，百度开源的工具包。在绘制的时候，只使用了依赖表和对外供应两张表。</p>
<h2 id="可视化思路"><a href="#可视化思路" class="headerlink" title="可视化思路"></a>可视化思路</h2><p>可视化的方式有很多种，我的需求是以最小成本，最快速度把这个可视化效果达成。不管是使用类似思维导图或draw.io这种工具，或者是编码实现，只要可以实现，任何方式都可以考虑。</p>
<p>我考虑的第一种方式，是使用draw.io。它确实提供了很多模型，但是最终我发现，手动去绘图，会花很多时间，然后效果还一般。<br>大概花了总共2小时的时间，发现用draw.io来绘制十多个系统之间复杂的连接，还是有点难。</p>
<p>所以，我考虑第二种方式是使用思维导图。确实思维导图很快可以把图建立起来，因为执行一次<code>回车</code>操作就可以生成一个方框，速度非常快。但是我嫌这个图不好看。<br>还没等我完成全部的系统和系统之间的连线，我就不想再做下去了。</p>
<p>最后，我决定使用编码的方式实现。这样的好处有两点：第一是生成的图形会很好看，效果好，第二是后续的维护会自动化，一劳永逸。</p>
<h2 id="实现可视化"><a href="#实现可视化" class="headerlink" title="实现可视化"></a>实现可视化</h2><p>经过调研了几个框架，包括pyecharts，politly，最终我发现pyecharts的关系图其实可以实现我的想法。</p>
<p>我基于<a href="https://gallery.pyecharts.org/#/Graph/graph_les_miserables">https://gallery.pyecharts.org/#/Graph/graph_les_miserables</a>这个案例实现了想要的效果。</p>
<p>效果图如下，使用菱形图表示系统，圆形便是系统的数据：<br><img src="/images/result1.png" alt="效果图"></p>
<h2 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h2><p>相关的代码或文件分三部分，第一部分是包含系统关系的原始文件，放在files_excel目录下，第二部分是用于生成表示图形信息的json文件的python脚本<code>build_json_system_relation.py</code>，第三部分是绘制图形的代码文件<code>generate_relations.py</code>。</p>
<h3 id="数据关系文件"><a href="#数据关系文件" class="headerlink" title="数据关系文件"></a>数据关系文件</h3><p>files_excel目录下的文件，每个文件包含两个sheet（表单），即<code>对外供应数据表清单</code>和<code>所依赖外部系统数据表清单</code>。</p>
<p><code>对外供应数据表清单</code>表单的格式如下：</p>
<table>
<thead>
<tr>
<th align="center">目的系统</th>
<th align="center">数据英文名</th>
<th align="center">数据中文名</th>
<th align="center">数据交换方式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">B</td>
<td align="center">table1</td>
<td align="center">数据1</td>
<td align="center">交易线</td>
</tr>
<tr>
<td align="center">C</td>
<td align="center">table2</td>
<td align="center">数据2</td>
<td align="center">数据线</td>
</tr>
<tr>
<td align="center">D</td>
<td align="center">table3</td>
<td align="center">数据3</td>
<td align="center">数据线</td>
</tr>
</tbody></table>
<p><code>所依赖外部系统数据表清单</code>表单的格式与上面类似，不过第一列是源系统。</p>
<p>上述两个文件就是我们要使用到的系统数据关系文件。如果有工具可以产生上述文件，那所有的步骤都可以自动化完成，包括生成本文讲的这种简单的关系图。如果不能自动生成，那么可能需要人工维护。所以建议还是都能实现自动化。关于如何产生上述关系，不在本文范围内，不过我觉得这种关系在任何一家公司都会维护起来的，比如通过提供一个维护页面维护上述两张表。</p>
<h3 id="生成表示图形中节点和边的JSON文件"><a href="#生成表示图形中节点和边的JSON文件" class="headerlink" title="生成表示图形中节点和边的JSON文件"></a>生成表示图形中节点和边的JSON文件</h3><p>现在我们已经有了原始关系文件，这种文件一般是for人类的，就是说给人看和维护的。那么现在我们需要把它们转成给代码使用的json文件。</p>
<p>json文件格式大致如下，可以先了解一下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;categories&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;data node&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;symbol&quot;</span>: <span class="string">&quot;circle&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;system node&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;symbol&quot;</span>: <span class="string">&quot;diamond&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;nodes&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;label&quot;</span>: <span class="string">&quot;SYSTEM_A&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;SYSTEM_A&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;category&quot;</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;label&quot;</span>: <span class="string">&quot;SYSTEM_B&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;SYSTEM_B&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;category&quot;</span>: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;label&quot;</span>: <span class="string">&quot;SYSTEM_C&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;SYSTEM_C&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;category&quot;</span>: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;label&quot;</span>: <span class="string">&quot;SYSTEM_A#table1&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;SYSTEM_A#table1&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;category&quot;</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;edges&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;sourceID&quot;</span>: <span class="string">&quot;SYSTEM_A#table1&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;attributes&quot;</span>: &#123;&#125;,</span><br><span class="line">      <span class="attr">&quot;targetID&quot;</span>: <span class="string">&quot;SYSTEM_B&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;size&quot;</span>: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;sourceID&quot;</span>: <span class="string">&quot;SYSTEM_A#table1&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;attributes&quot;</span>: &#123;&#125;,</span><br><span class="line">      <span class="attr">&quot;targetID&quot;</span>: <span class="string">&quot;SYSTEM_C&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;size&quot;</span>: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述文件包含了三部分，第一份是<code>categories</code>，表示分类，可以将节点进行分类，方便区分；第二部分是<code>nodes</code>，表示图中所有节点，第三部分是<code>edges</code>表示图中所有边。</p>
<p>生成上述JSON文件的大概思路或算法是这样的：使用pandas读取excel表的数据，第一列（源或目的系统）作为系统节点，而第三列也就是数据列作为数据节点，对应JSON文件中的<code>nodes</code>中的每个元素。每一行都是一个关系，作为一条边，源节点是数据节点，目的节点是系统节点，对应JSON文件中的<code>edges</code>中的每个元素。通过遍历所有excel文件中的两个表单的每一行（非空），建立节点、边的信息，形成一个大的JSON文件。</p>
<p>关键代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_all_node_data</span>(<span class="params">data_dir</span>):</span></span><br><span class="line">    all_node_data = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> os</span><br><span class="line">    <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(data_dir):</span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">            <span class="comment"># get node data</span></span><br><span class="line">            filepath = os.path.join(root, file)</span><br><span class="line">            all_node_data.extend(read_data_from_excel(filepath))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> all_node_data</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_data_from_excel</span>(<span class="params">filename</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;从excel读取数据，数据项作为一个节点（信息类）&quot;&quot;&quot;</span></span><br><span class="line">    out = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 系统节点</span></span><br><span class="line">    system_name = get_system_name(filename)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读取&quot;对外供应数据表清单&quot;</span></span><br><span class="line">    <span class="comment"># 目的系统名称 表英文名 表中文名称 数据供应方式（交易线，数据线）</span></span><br><span class="line">    data = pd.read_excel(filename, sheet_name=<span class="string">&quot;对外供应数据表清单&quot;</span>, engine=<span class="string">&quot;openpyxl&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)):</span><br><span class="line">        row = data.iloc[i]</span><br><span class="line">        info_name = system_name + <span class="string">&quot;#&quot;</span> + trim_node_name(row[<span class="number">2</span>])  <span class="comment"># 类似 A#财务数据 这种格式</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 处理以/分隔的多个系统</span></span><br><span class="line">        system_target_list = []</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;/&quot;</span> <span class="keyword">in</span> row[<span class="number">0</span>]:</span><br><span class="line">            systems = <span class="built_in">str</span>.split(row[<span class="number">0</span>], <span class="string">&quot;/&quot;</span>)</span><br><span class="line">            <span class="keyword">for</span> system <span class="keyword">in</span> systems:</span><br><span class="line">                system_target = get_system_name(system)</span><br><span class="line">                <span class="keyword">if</span> system_target <span class="keyword">not</span> <span class="keyword">in</span> SYSTEM_IGNORE:</span><br><span class="line">                    system_target_list.append(system_target)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            system_target = get_system_name(row[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">if</span> system_target <span class="keyword">not</span> <span class="keyword">in</span> SYSTEM_IGNORE:</span><br><span class="line">                system_target_list.append(system_target)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> system_target <span class="keyword">in</span> system_target_list:</span><br><span class="line">            tmp_node = copy.deepcopy(generate_node_data(info_name, system_target, row[<span class="number">1</span>], row[<span class="number">2</span>], row[<span class="number">3</span>]))</span><br><span class="line">            out.append(tmp_node)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读取&quot;所依赖外部系统数据表清单&quot;</span></span><br><span class="line">    <span class="comment"># 目的系统名称 表英文名 表中文名 数据供应方式（交易线，数据线）</span></span><br><span class="line">    data2 = pd.read_excel(filename, sheet_name=<span class="string">&quot;所依赖外部系统数据表清单&quot;</span>, engine=<span class="string">&quot;openpyxl&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data2)):</span><br><span class="line">        row = data2.iloc[i]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 处理以/分隔的多个系统</span></span><br><span class="line">        system_src_list = []</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;/&quot;</span> <span class="keyword">in</span> row[<span class="number">0</span>]:</span><br><span class="line">            systems_src = <span class="built_in">str</span>.split(row[<span class="number">0</span>], <span class="string">&quot;/&quot;</span>)</span><br><span class="line">            <span class="keyword">for</span> system <span class="keyword">in</span> systems_src:</span><br><span class="line">                system_src_list.append(system)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            system_src_list.append(row[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        system_target = system_name</span><br><span class="line">        <span class="keyword">for</span> system <span class="keyword">in</span> system_src_list:</span><br><span class="line">            system_name_src = get_system_name(system)</span><br><span class="line">            <span class="keyword">if</span> system_name_src <span class="keyword">not</span> <span class="keyword">in</span> SYSTEM_IGNORE:</span><br><span class="line">                info_name = system_name_src + <span class="string">&quot;#&quot;</span> + trim_node_name(row[<span class="number">2</span>])</span><br><span class="line">                tmp_node = copy.deepcopy(generate_node_data(info_name, system_target, row[<span class="number">1</span>], row[<span class="number">2</span>], row[<span class="number">3</span>]))</span><br><span class="line">                out.append(tmp_node)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="使用pyecharts绘制图形"><a href="#使用pyecharts绘制图形" class="headerlink" title="使用pyecharts绘制图形"></a>使用pyecharts绘制图形</h3><p>现在已经有JSON文件了，工作完成了大部分。接下来就是编写代码绘制关系图，生成一个html文件。这个html文件是可交互的，可以移动鼠标或缩放。如果未来在这个页面增加其他一些检索或表格生成功能就更好了。可以作为未来继续尝试的点。这块没有什么算法逻辑。</p>
<p>关键代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">json_file = <span class="string">&quot;all_node_data.json&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(json_file, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data_local = f.read()</span><br><span class="line">    data = json.loads(data_local)</span><br><span class="line"></span><br><span class="line">nodes = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"># &quot;x&quot;: node[&quot;x&quot;],</span></span><br><span class="line">        <span class="comment"># &quot;y&quot;: node[&quot;y&quot;],</span></span><br><span class="line">        <span class="string">&quot;id&quot;</span>: node[<span class="string">&quot;id&quot;</span>],</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: node[<span class="string">&quot;label&quot;</span>],</span><br><span class="line">        <span class="string">&quot;symbolSize&quot;</span>: node[<span class="string">&quot;size&quot;</span>],</span><br><span class="line">        <span class="string">&quot;symbol&quot;</span>: node[<span class="string">&quot;symbol&quot;</span>],</span><br><span class="line">        <span class="comment"># &quot;itemStyle&quot;: &#123;&quot;normal&quot;: &#123;&quot;color&quot;: node[&quot;color&quot;]&#125;&#125;,</span></span><br><span class="line">        <span class="string">&quot;category&quot;</span>: node[<span class="string">&quot;category&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> data[<span class="string">&quot;nodes&quot;</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">edges = [</span><br><span class="line">    &#123;<span class="string">&quot;source&quot;</span>: edge[<span class="string">&quot;sourceID&quot;</span>], <span class="string">&quot;target&quot;</span>: edge[<span class="string">&quot;targetID&quot;</span>], <span class="string">&quot;value&quot;</span>: edge[<span class="string">&quot;value&quot;</span>],</span><br><span class="line">     <span class="string">&quot;linestyle_opts&quot;</span>: opts.LineStyleOpts(type_=edge[<span class="string">&quot;type_&quot;</span>]),</span><br><span class="line">     &#125; <span class="keyword">for</span></span><br><span class="line">    edge <span class="keyword">in</span> data[<span class="string">&quot;edges&quot;</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">categories = data[<span class="string">&quot;categories&quot;</span>]</span><br><span class="line"></span><br><span class="line">(</span><br><span class="line">    Graph(init_opts=opts.InitOpts(width=<span class="string">&quot;1600px&quot;</span>, height=<span class="string">&quot;1200px&quot;</span>))</span><br><span class="line">        .add(</span><br><span class="line">        series_name=<span class="string">&quot;&quot;</span>,</span><br><span class="line">        nodes=nodes,</span><br><span class="line">        links=edges,</span><br><span class="line">        categories=categories,</span><br><span class="line">        layout=<span class="string">&quot;circular&quot;</span>,  <span class="comment"># circular , force, none</span></span><br><span class="line">        is_roam=<span class="literal">True</span>,</span><br><span class="line">        is_focusnode=<span class="literal">True</span>,</span><br><span class="line">        repulsion=<span class="number">100</span>,</span><br><span class="line">        is_rotate_label=<span class="literal">True</span>,</span><br><span class="line">        label_opts=opts.LabelOpts(is_show=<span class="literal">True</span>, position=<span class="string">&quot;right&quot;</span>),</span><br><span class="line">        linestyle_opts=opts.LineStyleOpts(width=<span class="number">1</span>, curve=<span class="number">0.3</span>, opacity=<span class="number">1.0</span>),  <span class="comment"># type_=&quot;solid&quot;</span></span><br><span class="line">        edge_symbol=[<span class="string">&quot;&quot;</span>, <span class="string">&quot;arrow&quot;</span>],  <span class="comment"># 单向箭头</span></span><br><span class="line">        edge_label=opts.LabelOpts(</span><br><span class="line">            is_show=<span class="literal">False</span>, position=<span class="string">&quot;middle&quot;</span>, formatter=<span class="string">&quot;&#123;b&#125;: &#123;c&#125; &quot;</span>  <span class="comment"># 设置关系说明</span></span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">        .set_global_opts(title_opts=opts.TitleOpts(title=<span class="string">&quot;系统数据关系图&quot;</span>),</span><br><span class="line">                         legend_opts=opts.LegendOpts(orient=<span class="string">&quot;vertical&quot;</span>, pos_left=<span class="string">&quot;2%&quot;</span>, pos_top=<span class="string">&quot;20%&quot;</span>), )</span><br><span class="line">        .render(<span class="string">&quot;relations-systems.html&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>代码地址：<a href="https://gitee.com/zackli518/charts_system_relations/tree/master">https://gitee.com/zackli518/charts_system_relations/tree/master</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>参考：</p>
<ul>
<li><a href="https://cloud.tencent.com/developer/article/1741359">https://cloud.tencent.com/developer/article/1741359</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/358471558">https://zhuanlan.zhihu.com/p/358471558</a> 了解了比较多类的属性</li>
<li><a href="https://gallery.pyecharts.org/#/Graph/graph_les_miserables">https://gallery.pyecharts.org/#/Graph/graph_les_miserables</a> 官方文档说明，案例比较丰富</li>
<li><a href="https://github.com/pyecharts/pyecharts-gallery">https://github.com/pyecharts/pyecharts-gallery</a> pyecharts的github地址</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>pyecharts</tag>
        <tag>python</tag>
        <tag>可视化</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建JMeter分布式测试环境</title>
    <url>/2021/09/16/%E6%90%AD%E5%BB%BAJMeter%E5%88%86%E5%B8%83%E5%BC%8F%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h2 id="分布式测试概述"><a href="#分布式测试概述" class="headerlink" title="分布式测试概述"></a>分布式测试概述</h2><p>现在我们来了解如何使用多台机器来执行压力测试，也就是所谓的分布式测试。当我们模拟大量的并发虚拟用户时，比如我们要起10万、100万甚至更多的并发用户时，一台负载机器可能就满足不了我们需要的用户量。此时，就需要使用多台主机搭建一套多节点的分布式性能测试环境，使得我们可以执行大规模并发测试。这是执行分布式性能测试的基本原因。当然可能还有其他一些场景，比如我们可以建立一套测试云平台，也需要搭建分布式测试环境，来满足多租户需求。</p>
<p>在搭建JMeter分布式测试环境和利用该环境执行性能或压力测试时，首次需要执行的操作包括：</p>
<ol>
<li>准备测试环境，主要是准备用于运行JMeter进程的机器，可以是Windows机器，也可以是Unix类机器包括Linux操作系统的机器。包括安装部署JMeter及依赖的Java环境。第一次准备之后，后面的测试就可以复用这些环境了</li>
<li>设置分布式环境没台机器上的JMeter节点的配置</li>
<li>准备要运行的测试脚本。可在JMeter的GUI界面上，先编好测试计划，然后下载到分布式环境中的主控制节点上。此处要主次使用的JMeter的版本要匹配，否则可能产生莫名错误</li>
<li>启动分布式测试</li>
<li>查看和分析测试结果</li>
<li>可能需要进行一些问题处理或服务器调优。如果压力不够，可能还需要增加机器，此时可以参考步骤1中的操作了</li>
</ol>
<h2 id="准备测试环境"><a href="#准备测试环境" class="headerlink" title="准备测试环境"></a>准备测试环境</h2><p>和其他分布式系统类似，使用JMeter搭建分布式测试系统，结构也基本是一主多从的架构，包括一台主控制节点，多个工作节点。</p>
<p><img src="./imgs/distributed-names.svg" alt="dirstributed-nodes"></p>
<p>在开始执行分布式测试之前，首先要准备负载机器。作为实践案例，我们使用三台Linux机器构建一个分布式测试环境，构建一主二从的结构。在执行测试时，由JMeter 主控制器节点（主节点）在多个工作节点（从节点）上启动测试。使用<code>ifconfig</code>命令查看机器的ip地址，记录IP地址备用。本例使用的三台机器ip地址分别为<br>192.168.1.180、192.168.1.181、192.168.1.182，其中将192.168.1.180作为主节点。</p>
<p>首先对三台服务器执行下述检查：</p>
<ul>
<li>系统上的防火墙已关闭或打开了正确的端口。在实验环境下，可以关闭防火墙；在正式的测试环境下，建议不要关闭防火墙，打开相关的端口即可</li>
<li>所有负载机器都在同一个子网上，确保可以互通</li>
<li>确保三台负载机可以访问被测服务器</li>
<li>确保在所有系统上使用相同版本的 JMeter 和 Java。混合版本将无法正常工作</li>
<li>已经为 RMI 设置了 SSL或禁用SSL。参考<a href="../5%20remote_testing/5.1%20JMeter%E8%BF%9C%E7%A8%8B%E6%B5%8B%E8%AF%95.md">远程测试</a>。</li>
</ul>
<h2 id="设置分布式环境"><a href="#设置分布式环境" class="headerlink" title="设置分布式环境"></a>设置分布式环境</h2><h3 id="设置主控节点"><a href="#设置主控节点" class="headerlink" title="设置主控节点"></a>设置主控节点</h3><p>完成上述测试环境准备和检查工作后，需要在主节点上进行如下设置。主控节点有时成为client节点，因为相对工作节点来说，它就是一个client，而工作节点是server节点。</p>
<p>在作为控制台的控制器节点（192.168.1.180）上，在jmeter/bin目录打开jmeter.properties进行编辑。</p>
<p>首先找到remote_hosts，设置为<code>remote_hosts=192.168.1.181,192.168.1.182</code>，其次，设置client.rmi.localport的值，表示控制节点将使用这个指定的端口与工作节点通信。其他设置使用默认值。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">remote_hosts</span>=<span class="string">192.168.1.181,192.168.1.182</span></span><br><span class="line"><span class="meta">client.rmi.localport</span>=<span class="string">5000</span></span><br><span class="line"><span class="meta">server.rmi.ssl.disable</span>=<span class="string">true #设为true表示rmi不使用ssl进行通信</span></span><br></pre></td></tr></table></figure>

<p>JMeter分布式环境中，主控节点和工作节点之间通过RMI进行服务调用。在上面配置中，主控节点使用5000与工作节点通信，如果打开了防火墙，那么要打开5000端口。</p>
<blockquote>
<p>特别说明一下server.rmi.localport、server_ports、client.rmi.localport这几个相似配置的关系和区别：<br>server_ports指Java RMI注册表的端口，只需在工作节点配置。server.rmi.localport为工作节点使用的RMI本地端口，client.rmi.localport为主控节点使用的RMI本地端口，如果不设置，则JMeter使用动态端口互相通信。在开启防火墙的情况，需要指定端口，避免随机动态端口不能访问。</p>
</blockquote>
<p>另外，从 JMeter 4.0 开始，RMI 的默认传输机制将使用 SSL。本例为了简便期间，关闭使用SSL的机制。如果希望继续使用SSL，需要密钥和证书才能工作，参考<a href="../5%20remote_testing/5.1%20JMeter%E8%BF%9C%E7%A8%8B%E6%B5%8B%E8%AF%95.md">JMeter远程测试</a>中关于SSL的设置。</p>
<h3 id="设置工作节点"><a href="#设置工作节点" class="headerlink" title="设置工作节点"></a>设置工作节点</h3><p>正如上面说的，工作节点在JMeter分布式测试环境中，也称为server节点（服务节点）。不过注意这个服务节点与被测服务不同，要区分开。</p>
<p>在jmeter/bin目录打开jmeter.properties进行编辑。在工作节点上设置server.rmi.localport的值，表示工作节点将使用这个指定的端口与控制节点通信：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">server.rmi.localport</span>=<span class="string">4000</span></span><br><span class="line"><span class="meta">server.rmi.ssl.disable</span>=<span class="string">true #设为true表示rmi不使用ssl进行通信</span></span><br></pre></td></tr></table></figure>

<h2 id="执行分布式测试"><a href="#执行分布式测试" class="headerlink" title="执行分布式测试"></a>执行分布式测试</h2><p>一旦确定系统准备就绪，就可以设置远程测试了。</p>
<h3 id="启动工作节点"><a href="#启动工作节点" class="headerlink" title="启动工作节点"></a>启动工作节点</h3><p>在工作节点上（192.168.1.181和192.168.1.182），转到jmeter/bin目录并执行 jmeter-server（在 windows 上为jmeter-server.bat）。</p>
<p>运行成功的输出如下，表明控制节点可以开始调用该工作节点执行分布式测试了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@192.168.1.181 bin]<span class="comment"># ./jmeter-server</span></span><br><span class="line">Using <span class="built_in">local</span> port: 4000</span><br><span class="line">Created remote object: UnicastServerRef2 [liveRef: [endpoint:[192.168.1.181:4000](<span class="built_in">local</span>),objID:[7eec802e:17beeece6e9:-7fff, -4396200611540390478]]]</span><br></pre></td></tr></table></figure>

<p>如果没有看到此消息，则表示jmeter-server未正确启动。相关问题的解决可转到本文后面的<a href="#%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3">问题及解决</a>一章。</p>
<h3 id="启动分布式测试"><a href="#启动分布式测试" class="headerlink" title="启动分布式测试"></a>启动分布式测试</h3><p>分布式性能测试中，一定要以非GUI的方式启动测试。因此，接下来只介绍以非GUI方式运行jmeter执行分布式测试。</p>
<p>假设我们需要执行的测试计划脚本是test_on_linux.jmx，并希望把测试日志存储到test.jtl中，那么只需要把test_on_linux.jmx部署到主控节点，无需部署到工作节点。在执行测试时，主控节点会自动分发测试任务给工作节点。</p>
<p>下面开始正式启动测试。在控制节点（即192.168.1.180这台机器）上的jmeter/bin目录下执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./jmeter -n -t test_on_linux.jmx -l test_queryweb.jtl -R192.168.1.181,192.168.1.182</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参数说明：</p>
<p>-n表示以nogui方式运行测试计划</p>
<p>-t表示测试计划，后面跟测试计划名称</p>
<p>-l表示测试结果，后面跟测试结果文件名称</p>
<p>-R表示JMeter代理（工作节点），后面跟代理所在ip地址。注意，上面的命令只在ip1和ip2上运行测试，而当前机器作为主控台负责收集数据。</p>
</blockquote>
<p>如果没有错误，则打印类似如下信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@hadoop0 bin]<span class="comment"># ./jmeter -n -t test_on_linux.jmx -l test_queryweb.jtl -R192.168.1.181,192.168.1.182</span></span><br><span class="line">Creating summariser &lt;summary&gt;</span><br><span class="line">Created the tree successfully using test_on_linux.jmx</span><br><span class="line">Configuring remote engine: 192.168.1.181</span><br><span class="line">Configuring remote engine: 192.168.1.182</span><br><span class="line">Starting distributed <span class="built_in">test</span> with remote engines: [192.168.1.181, 192.168.1.182] @ Thu Sep 16 22:31:18 CST 2021 (1631802678465)</span><br><span class="line">Remote engines have been started:[192.168.1.181, 192.168.1.182]</span><br><span class="line">Waiting <span class="keyword">for</span> possible Shutdown/StopTestNow/HeapDump/ThreadDump message on port 4445</span><br><span class="line">summary =    100 <span class="keyword">in</span> 00:00:01 =   71.2/s Avg:    41 Min:    13 Max:   146 Err:     0 (0.00%)</span><br><span class="line">Tidying up remote @ Thu Sep 16 22:31:22 CST 2021 (1631802682161)</span><br><span class="line">... end of run</span><br></pre></td></tr></table></figure>

<p>此时查看两个工作节点，可以看到都会打印类似下述信息，说明正在执行主控节点启动的分布式测试任务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Starting the test on host 192.168.1.181 @ Thu Sep 16 22:31:20 CST 2021 (1631802680315)</span><br><span class="line">Finished the test on host 192.168.1.181 @ Thu Sep 16 22:31:22 CST 2021 (1631802682437)</span><br></pre></td></tr></table></figure>

<p>如希望以后台形式运行测试，则执行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nohup ./jmeter -n -t test_on_linux.jmx -l test_queryweb.jtl &amp; &gt; nohup.log</span><br></pre></td></tr></table></figure>

<h2 id="查看测试结果"><a href="#查看测试结果" class="headerlink" title="查看测试结果"></a>查看测试结果</h2><p>上述执行命令的输出信息中的<code>end of run</code>表示测试计划已经运行完毕。可在运行JMeter打开测试结果文件test_queryweb.jtl。</p>
<p>下面是在JMeter的GUI（图形化界面)上查看执行结果的步骤：</p>
<ol>
<li>step1：为测试计划添加查看结果树</li>
</ol>
<p>在打开的JMeter图形窗口，并新建或打开一个测试计划，为该计划添加“结果查看树”和“聚合报告”。</p>
<ol start="2">
<li>step2：打开jtl文件，以可视化方式查看测试结果</li>
</ol>
<p>打开查看结果树，点击“浏览”按钮打开测试结果文件test_queryweb.jtl。同理，打开聚合报告，点击“浏览”按钮打开测试结果文件test_queryweb.jtl生成聚合报告。</p>
<h2 id="问题及解决"><a href="#问题及解决" class="headerlink" title="问题及解决"></a>问题及解决</h2><h3 id="如果测试脚本使用了csv等文件，必须放到工作节点上，否则会报错误"><a href="#如果测试脚本使用了csv等文件，必须放到工作节点上，否则会报错误" class="headerlink" title="如果测试脚本使用了csv等文件，必须放到工作节点上，否则会报错误"></a>如果测试脚本使用了csv等文件，必须放到工作节点上，否则会报错误</h3><p>错误信息示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2016/07/29 15:44:01 INFO  - jmeter.threads.JMeterThread: Thread started: 线程组 1-1</span><br><span class="line">2016/07/29 15:44:01 INFO  - jmeter.services.FileServer: Stored: csvRelation-vip.csv</span><br><span class="line">2016/07/29 15:44:01 ERROR - jmeter.config.CSVDataSet: java.io.FileNotFoundException: ./csvRelation-vip.csv (没有那个文件或目录)</span><br><span class="line">2016/07/29 15:44:01 INFO  - jmeter.threads.JMeterThread: Stop Thread seen: org.apache.jorphan.util.JMeterStopThreadException: End of file detected</span><br></pre></td></tr></table></figure>

<h3 id="运行时错误-Error-in-NonGUIDriver-java-lang-NullPointerException"><a href="#运行时错误-Error-in-NonGUIDriver-java-lang-NullPointerException" class="headerlink" title="运行时错误: Error in NonGUIDriver java.lang.NullPointerException"></a>运行时错误: Error in NonGUIDriver java.lang.NullPointerException</h3><p>产生该错误的原因，目前就我所知，有两种情况：</p>
<p>情况1，低版本的JMeter运行高版本的测试计划（测试计划是在高版本的JMeter上编制的）。解决方法：使用相同或更高版本JMeter运行该计划。</p>
<p>情况2，使用第三方插件生成的测试计划，运行在没有该第三方插件的JMeter上。解决方法：在JMeter上安装插件或重新生成不包含插件的测试计划。</p>
<h3 id="运行时错误-controller连接远程agent失败：Connection-refused-to-host"><a href="#运行时错误-controller连接远程agent失败：Connection-refused-to-host" class="headerlink" title="运行时错误: controller连接远程agent失败：Connection refused to host"></a>运行时错误: controller连接远程agent失败：Connection refused to host</h3><p>详细日志：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Failure connecting to remote host: 10.15.144.172 java.rmi.ConnectException: Connection refused to host: 10.15.144.172; nested exception is:</span><br><span class="line">    java.net.ConnectException: 拒绝连接</span><br><span class="line">Failed to configure 10.15.144.172</span><br><span class="line">Configuring remote engine for 10.15.144.173</span><br><span class="line">Using remote object: UnicastRef [liveRef: [endpoint:[10.15.144.173:42973](remote),objID:[-7fc64e11:1564b9635f8:-7fff, -3234805376461024374]]]</span><br><span class="line">Error in NonGUIDriver java.lang.IllegalArgumentException: The following remote engines could not be configured:[10.15.107.159, 10.15.107.241, 10.15.107.110, 10.15.107.116, 10.15.107.117, 10.15.144.85, 10.15.144.171, 10.15.144.172]</span><br></pre></td></tr></table></figure>

<p>分析原因。</p>
<ol>
<li>首先查看是否有开防火墙，如果开了请关闭。或打开相关端口。</li>
<li>然后查看jmeter-server进程是否启起来了。这次比较大意，只是把jmeter文件拷到目标机器上了，但是没有安装java环境，所以才导致jmeter启动失败。</li>
</ol>
<h3 id="防火墙问题"><a href="#防火墙问题" class="headerlink" title="防火墙问题"></a>防火墙问题</h3><p>在某些情况下，防火墙可能仍会阻止 RMI 流量。<br>在负载测试期间应停止防病毒软件，因为它会严重影响导致错误结果的时间。<br>对于Windows负载机，防火墙需要从 windows 服务中停止，或者至少需要打开一些端口。<br>在 Linux 上，iptables 可能默认是打开的。可停止 Linux 防火墙或确保已打开正确的端口。</p>
]]></content>
      <categories>
        <category>jmeter</category>
        <category>test</category>
      </categories>
      <tags>
        <tag>jmeter</tag>
        <tag>distributed</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>调试JMeter5源码</title>
    <url>/2021/09/08/%E8%B0%83%E8%AF%95JMeter5%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<h1 id="JMeter源码的开发调试"><a href="#JMeter源码的开发调试" class="headerlink" title="JMeter源码的开发调试"></a>JMeter源码的开发调试</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>本文编译这部分内容基本来源于网上。debug相关内容为本人根据实际情况整理。</p>
<p>JMeter5.2开始，使用gradle代替了原来ant，所以基于源码的本地环境搭建略有不同。JMeter 5.4.1使用的gradle文件不是build.gradle文件，而是build.gradle.kts。</p>
<h2 id="所需环境"><a href="#所需环境" class="headerlink" title="所需环境"></a>所需环境</h2><ul>
<li>JDK 8 +</li>
<li>JMeter 源码（本例使用的是5.4.1版本）</li>
<li>IntelliJ IDEA / Eclipse：本例使用IntelliJ IDEA CE 2020.3来构建本地开发环境（IDEA版本需要&gt;=2018.3.1）</li>
</ul>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>下面是在IDEA打开JMeter工程的步骤说明。</p>
<ol>
<li><p>启动idea，点击File -&gt; open，选中jmeter源码目录下build.gradle.kts</p>
</li>
<li><p>选择“Open as Project”</p>
</li>
<li><p>确保“Create separate module per source set” 和 “Use default gradle wrapper”选中，然后点击ok。（这两项不一定会有，可能和IDEA版本有关）</p>
</li>
</ol>
<p>随后idea会自动开始下载JMeter所需依赖，等待执行完成。</p>
<p><strong>注意 这里不要对Gradle设置阿里云镜像，否则会出现依赖加载不成功，在checksum时，会有部分依赖报错，开始前建议暂时取消Gradle的镜像。</strong></p>
<blockquote>
<p>为了不使用ali的gradle仓库，我把~/.gradle下的init.gradle（使用了ali的gradle库）重命名为init.gradle.bak了，这样gradle在运行的时候不再使用ali的库。</p>
</blockquote>
<p>依赖下载完成后，所需的依赖是在gradle的cache目录下，我们需要执行命令打包构建，将所需的依赖复制一份到jmeter源码目录的lib目录下。在Terminal中执行（gradle需要先配置环境变量）<code>gradlew runGui</code>。或在gradle任务下的developement下执行runGUI，以便在工程根目录下的lib下生成相关jar。</p>
<p>执行完成后，会打开构建好的jmeter GUI界面。查看lib目录，jar包也已复制完成。在调试之前，先关闭打开的JMeter界面。</p>
<h2 id="在IDEA中debug源码"><a href="#在IDEA中debug源码" class="headerlink" title="在IDEA中debug源码"></a>在IDEA中debug源码</h2><p>下面是debug设置的操作说明：</p>
<ol>
<li><p>在IDEA中，快捷键cmd+shift+f或double shift（mac电脑），搜索找到NewDriver类。</p>
</li>
<li><p>点击小锤子旁边的 Add Configuration…</p>
</li>
<li><p>增加Application设置，在VM options中加入 -Djmeter.home=xxx（JMeter源码目录），点击ok。</p>
</li>
</ol>
<p>对于jmeter 5.4.1 ，为了debug jmeter，我是这样设置的:</p>
<ol>
<li>修改run configuration如下：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vm option：</span><br><span class="line">-Djmeter.home=/Users/lizhiqiang/Test/src/jmeter -cp .;/Users/lizhiqiang/Test/src/jmeter</span><br><span class="line"></span><br><span class="line">classname：</span><br><span class="line">org.apache.jmeter.NewDriver</span><br><span class="line"></span><br><span class="line">environment variables:</span><br><span class="line">JMETER_HOME=/Users/lizhiqiang/Test/src/jmeter</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>生成lib下相关jar（<strong>如果之前已经执行过runGUI，不需要再执行</strong>）</p>
</li>
<li><p>修改代码</p>
</li>
</ol>
<p>因为代码逻辑设定，所以为了启动debug，需要修改少量代码。如果不修改代码，debug的时候会报错。因此在line 87行添加一行：<code>tmpDir = null; //lizhiqiang debug</code>。（可能是我的野路子）。记得这行代码在正式发布的时候去除或注释掉！</p>
<p>修改后这段代码是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">tmpDir = <span class="keyword">null</span>; <span class="comment">//lizhiqiang debug</span></span><br><span class="line"><span class="keyword">if</span> (tmpDir == <span class="keyword">null</span>) &#123;</span><br><span class="line">    tmpDir = System.getenv(<span class="string">&quot;JMETER_HOME&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，程序将使用环境变量JMETER_HOME定义的目录.</p>
<ol start="4">
<li>点击debug按钮，运行代码，随后会启动JMeter的GUI了，接下来我们就可以在想了解功能上，打断点或者修改源码，调试JMeter。</li>
</ol>
<h2 id="debug时相关错误"><a href="#debug时相关错误" class="headerlink" title="debug时相关错误"></a>debug时相关错误</h2><p>尝试使用过下面的命令，但可能都不是正确的方式，因为后面尝试了都不能将jmeter启动起来，最终还是按照之前提过的方法，不实用ali的仓库进行构建。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">检查校验和：构建完成后才检查校验和</span></span><br><span class="line">./gradlew clean build -Djava.awt.headless=true -PchecksumFailOn=build_finish</span><br><span class="line">-PchecksumFailOn=build_finish</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">不检查校验和，也不测试</span></span><br><span class="line">./gradlew clean build -Djava.awt.headless=true -PchecksumIgnore -x test</span><br></pre></td></tr></table></figure>

<p>下面是默认执行<code>gradle build</code>时出现的错误。这些校验和相关的错误要解决，否则可能后面还是不能运行成功。解决的方法在前面提过，就是不要使用ali的仓库（至少在我的实践看来是这样的。原因可能还是因为某些依赖的包不再ali的仓库里）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">错误信息：</span><br><span class="line">Checksum/PGP violations detected on resolving configuration :src:testkit-wiremock:compileClasspath</span><br><span class="line">  No PGP signature (.asc file) found for artifact:</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面的错误不记得是如何消除的了，但比较确定的一点是，没有checksum相关的错误后，下面的错误也没了：</p>
<ul>
<li>jmeter Caused by: java.io.FileNotFoundException:   subprojects/configuration-cache/src/main/kotlin (Is a directory)</li>
<li>其他一些错误：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Create separate module per source set</span><br><span class="line">Task :src:components:autostyleJavaCheck FAILED</span><br><span class="line">src:bshclient:autostyleJavaCheck FAILED</span><br><span class="line"> Task :src:testkit-wiremock:compileJava FAILED</span><br><span class="line">java/org/apache/jorphan/gui/DynamicStyle.java使用了未经检查或不安全的操作</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>构建文档：</p>
<ul>
<li><a href="https://github.com/apache/jmeter/blob/master/gradle.md">https://github.com/apache/jmeter/blob/master/gradle.md</a> 官方构建说明，可以找到关于不同构建命令的说明</li>
</ul>
]]></content>
      <categories>
        <category>jmeter</category>
      </categories>
      <tags>
        <tag>jmeter</tag>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title>使用JMeter测试服务器基准性能</title>
    <url>/2021/09/18/%E4%BD%BF%E7%94%A8JMeter%E6%B5%8B%E8%AF%95%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E5%87%86%E6%80%A7%E8%83%BD/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>通过对服务器进行基准测试（通常所说的benchmark测试），可得到服务器的基准性能。对于运行web服务的服务器而言，它的基准性能值让我们得以了解服务器本身所能承受的最大并发压力，是任何一个部署到该服务器的web服务的理论并发上限。有些设计良好的web服务能达到或接近这样的数值，而有些则不能。总之，基准能力的高低，不仅涉及到web服务本身的并发能力设计水平，也与服务器的软硬件资源配置和优化设置相关。</p>
<p>本文使用JMeter和其他性能测试工具，对一台运行NGINX服务的8C16G配置的标准Linux虚拟机进行基准性能测试，并尝试对NGINX和服务器本身进行调优，以使其发挥最大并发处理能力。本次使用NGINX作为被测web服务，不涉及数据库操纵或其他处理逻辑，只是简单返回响应消息，这样可以得到一个最大的并发处理数据，我们使用QPS即每秒处理请求数（quest per second）表示。</p>
<h2 id="准备被测环境"><a href="#准备被测环境" class="headerlink" title="准备被测环境"></a>准备被测环境</h2><p>准备两台负载机器用于产生压力，另外准备一台服务器作为被测机器。三台机器都位于同一台物理机器上，每台机器配置都是8C16GB的设置。</p>
<p>我们是使用JMeter执行分布式测试，所以自然在两台测试机器上安装好JMeter，并配置好分布式执行环境。其中一台机器即作为主控节点也作为工作节点。具体怎么配置分布式环境见另外一篇文章<a href="https://blog.csdn.net/ceo158/article/details/120357653">搭建JMeter分布式测试环境</a>。在被测服务器上安装必备的基础软件，包括jdk、python等，具体安装方法网上自查。其中jdk是运行JMeter所必备，python主要是用来运行用于统计数据的脚本。</p>
<h3 id="被测服务"><a href="#被测服务" class="headerlink" title="被测服务"></a>被测服务</h3><p>使用NGINX作为被测的web服务器。NGINX是一个高性能的web服务或反向代理服务器，性能非常强劲。根据NGINX官方的测试报告<a href="https://www.nginx.com/blog/testing-the-performance-of-nginx-and-nginx-plus-web-servers/">戳这里</a>，NGINX在一台8C16G的物理服务器（所谓裸金属服务器）的基准性能是，当并发连接为400个、且响应返回的文件大小是1KB的时候，QPS可以达到26w多，非常的高。</p>
<p>我们本次实验使用的机器是虚拟机，CPU品牌和NGINX官网上那篇文章使用的基本一样，都是<code>Intel至强处理器</code>，但是具体型号有差异，CPU频率略低一些。所以我的测试目的是能够尽量接近官方的这个QPS数值。</p>
<h2 id="测试工具"><a href="#测试工具" class="headerlink" title="测试工具"></a>测试工具</h2><p>使用的测试工具包括ab、wrk、jmeter。其中ab、wrk都是作为jmeter的对照物。也可以使用其他工具，比如gatling对比一下。此次使用ab、wrk互为印证就够了。</p>
<p>使用apache benchmark（简称ab）和wrk执行最基础的测试，用来作为与JMeter分布式测试的效果的对比。有对比才有高下之分对吧。ab和wrk纯粹作为互相参照印证的工具。</p>
<p>1）安装ab</p>
<p>在CentOS上安装ab，只需要一行命令：<code>yum install /usr/bin/ab</code>。安装好以后在命令行执行<code>ab</code>验证是否成功。</p>
<p>2）安装wrk</p>
<p>先安装git，因为make的时候需要用到。下载git工程后安装，工程地址<a href="https://github.com/wg/wrk">https://github.com/wg/wrk</a>。下载后进入wrk的git工程目录直接执行make，得到一个二进制文件wrk，这个就是可执行程序。</p>
<p>3）安装jmeter</p>
<p>在<a href="https://jmeter.apache.org/download_jmeter.cgi">jmeter官网</a>下载解压即可。部署分布式环境请参考另外一篇文章<a href="https://johnny1952.github.io/2021/09/16/%E6%90%AD%E5%BB%BAJMeter%E5%88%86%E5%B8%83%E5%BC%8F%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83/">搭建JMeter分布式测试环境</a>。</p>
<h2 id="服务器和NGINX服务优化"><a href="#服务器和NGINX服务优化" class="headerlink" title="服务器和NGINX服务优化"></a>服务器和NGINX服务优化</h2><ol>
<li>对负载机和被测服务器均进行相关优化，具体优化可参考我的另外一篇博客<a href="https://johnny1952.github.io/2021/10/05/CentOS7%E8%B0%83%E4%BC%98%E5%AE%9E%E8%B7%B5/">CentOS7调优实践</a>。</li>
<li>对NGINX服务进行设置优化：<br>需要优化的配置包括如下（更多见具体nginx.conf文件中的设置）：</li>
</ol>
<ul>
<li>worker_rlimit_nofile：为nginx的work进程所运行的用户（一般是nginx）设置可打开的最大文件数</li>
<li>worker_connections：最大访问客户数,修改此值时,不能超过 worker_rlimit_nofile 值</li>
<li>worker_processes：worker进程数，一般设为auto即可，也可以设为等于或超过cpu数的数量，不宜超过太多</li>
<li>worker_cpu_affinity：cpu亲和性</li>
<li>keepalive_requests：这个还没配过，默认是1000。这个配置项是nginx对于单个keepalive连接可处理的请求的数量。低于1.19.10的版本默认是100. 关于这点有人也做了探索，见 <a href="https://github.com/jinhailang/blog/issues/37">https://github.com/jinhailang/blog/issues/37</a>。因为我测试的时候每个连接都只发100个请求，所以默认值够用了。但是如果一个请求要发送很多请求，比如长时间的压力测试，那么这个值可能要设置的比较大一些好点。</li>
<li>keepalive_timeout：空闲保活连接保持打开状态的时间。默认是75s。默认值即可。</li>
<li>access_log：设置日志路径和级别</li>
</ul>
<p>nginx.conf完整配置见附录<a href="#nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%A4%BA%E4%BE%8B">nginx配置文件示例</a>。</p>
<h2 id="执行测试"><a href="#执行测试" class="headerlink" title="执行测试"></a>执行测试</h2><h3 id="使用ab执行测试"><a href="#使用ab执行测试" class="headerlink" title="使用ab执行测试"></a>使用ab执行测试</h3><p>压测nginx的主页地址，nginx将返回一段大小不到1KB的文本。</p>
<p>1）用例1：单台负载机启动8个ab进程使用大连接数进行测试</p>
<p>单机启动8个ab进程压测，qps大概可以达到2.6w左右。负载机cpu和被测服务器的cpu利用都大概50%左右。</p>
<p>具体测试命令是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过脚本多进程压测，根据cpu数启动相应个数的ab进程。每个并发60000，实现6k*8=4.8w个并发</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">rm -rf *.<span class="built_in">log</span></span><br><span class="line"><span class="keyword">for</span>((i=1;i&lt;=8;i++));</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  nohup ab -k -r -n 600000 -c 6000 <span class="string">&quot;http://192.168.1.182:80/&quot;</span>  &gt; request<span class="variable">$&#123;i&#125;</span>.<span class="built_in">log</span> 2&gt;&amp;1 &amp;</span><br><span class="line">  sleep 1</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>下面是查看8个ab进程的测试结果，每个进程的qps综合相加就是总的qps：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@hadoop0 performance_test]<span class="comment"># cat request1.log  | grep &quot;Requests per second:&quot;</span></span><br><span class="line">Requests per second:    4025.82 [<span class="comment">#/sec] (mean)</span></span><br><span class="line">[root@hadoop0 performance_test]<span class="comment"># cat request2.log  | grep &quot;Requests per second:&quot;</span></span><br><span class="line">Requests per second:    3097.47 [<span class="comment">#/sec] (mean)</span></span><br><span class="line">[root@hadoop0 performance_test]<span class="comment"># cat request3.log  | grep &quot;Requests per second:&quot;</span></span><br><span class="line">Requests per second:    3266.06 [<span class="comment">#/sec] (mean)</span></span><br><span class="line">[root@hadoop0 performance_test]<span class="comment"># cat request4.log  | grep &quot;Requests per second:&quot;</span></span><br><span class="line">Requests per second:    3284.48 [<span class="comment">#/sec] (mean)</span></span><br><span class="line">[root@hadoop0 performance_test]<span class="comment"># cat request5.log  | grep &quot;Requests per second:&quot;</span></span><br><span class="line">Requests per second:    3338.12 [<span class="comment">#/sec] (mean)</span></span><br><span class="line">[root@hadoop0 performance_test]<span class="comment"># cat request6.log  | grep &quot;Requests per second:&quot;</span></span><br><span class="line">Requests per second:    3120.59 [<span class="comment">#/sec] (mean)</span></span><br><span class="line">[root@hadoop0 performance_test]<span class="comment"># cat request7.log  | grep &quot;Requests per second:&quot;</span></span><br><span class="line">Requests per second:    3127.17 [<span class="comment">#/sec] (mean)</span></span><br><span class="line">[root@hadoop0 performance_test]<span class="comment"># cat request8.log  | grep &quot;Requests per second:&quot;</span></span><br><span class="line">Requests per second:    3156.94 [<span class="comment">#/sec] (mean)</span></span><br></pre></td></tr></table></figure>

<p>2）用例2：2台负载机每台启动8个ab进程使用大连接数进行测试</p>
<p>同时使用两台负载机进行压测。每台启动8个ab进程，并发约4.8w（在可允许的端口数范围内），两台机器理论可以启动约9.6万ab进程压测。测试命令与用例1相同。不过还是没有能使被测服务器达到90%以上cpu利用率。</p>
<p>经过多次测试，两台机器得到总qps是接近3w，相比单台机器压测，并没有多大提升：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@hadoop0 performance_test]<span class="comment"># python ./calculate_ab_qps.py</span></span><br><span class="line">(<span class="string">&#x27;total qps is : &#x27;</span>, 16312.919999999998)</span><br><span class="line">[root@hadoop1 performance_test]<span class="comment"># python ./calculate_ab_qps.py</span></span><br><span class="line">(<span class="string">&#x27;total qps is : &#x27;</span>, 13512.26)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>calculate_ab_qps.py是一个汇总计算各request.log中qps数据并汇总的python小工具。</p>
</blockquote>
<p>结论是：在大连接数量的情况，通过ab测试得到的被测NGINX服务器的性能大约就是3w。</p>
<p>3）用例3: 2台压力负载机器均使用少连接数进行测试</p>
<p>作为对比，使用较少的连接数进行测试。此种情况下，被测服务器的CPU利用率应比大连接时更高。</p>
<p>测试命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过脚本多进程压测，根据cpu数启动相应个数的ab进程。每个并发50，实现50*8=400个并发</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">rm -rf *.<span class="built_in">log</span></span><br><span class="line"><span class="keyword">for</span>((i=1;i&lt;=8;i++));</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  nohup ab -k -r -n 600000 -c 50 <span class="string">&quot;http://192.168.1.182:80/&quot;</span>  &gt; request<span class="variable">$&#123;i&#125;</span>.<span class="built_in">log</span> 2&gt;&amp;1 &amp;</span><br><span class="line">  sleep 1</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>两台负载机器测试得到的QPS大约相等，差不多都是4.8w，相加总和是9.6w，所以被测NGINX的QPS是9.6w左右。资源消耗方面，被测服务器CPU利用率可以达到80%左右，网络负载在700Mbps左右，大约是70%的利用率。此时服务器资源看起来还是有一定的余量。然而压测端CPU利用率没有超过50%，包括内存、网络等都没有到瓶颈，似乎可以增加更多压力。有机会可以再进行探索测试，比如尝试启用更多ab进程，比如设置进程数为CPU数的150%。</p>
<h3 id="使用wrk执行测试"><a href="#使用wrk执行测试" class="headerlink" title="使用wrk执行测试"></a>使用wrk执行测试</h3><p>1）用例1: 低连接数模式</p>
<p>两台负载机每台以较低数量的连接数，保持keepalive，对服务器发送请求。<br>具体测试命令如下，每台机器使用8个wrk进程，每个进程也都设置为单线程，这样效率最高：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `seq 0 7`; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;worker <span class="variable">$i</span>\n&quot;</span></span><br><span class="line">    taskset -c <span class="variable">$i</span> /opt/wrk/wrk -t 1 -c 50 -d 180s http://192.168.1.182:80/ &amp;</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>每台机器测试得到的结果qps大约5w，两台的总和就是10万。现在终于把这台被测机器的极限处理性能给测试出来了！被测服务器cpu使用率压到接近100%，已经不能再提上去了，因为NGINX所在服务器的cpu现在已经是瓶颈了！除非提升硬件配置。</p>
<p>2）用例2: 高连接数模式</p>
<p>换一种测试方式。上面是测试较少连接（connection）的情况下NGINX服务器的处理性能。接下来尝试大并发连接的情况下NGINX的处理性能。</p>
<p>每个进程起7000个连接，一台机器则连接总数总共是5.6w，不超过可用端口总数（大约是6w左右），命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `seq 0 7`; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;worker <span class="variable">$i</span>\n&quot;</span></span><br><span class="line">    taskset -c <span class="variable">$i</span> /opt/wrk/wrk -t 1 -c 7000 -d 300s http://192.168.1.182:80/ &amp;</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>这种情况下，服务器的cpu利用率没有上一种模式那么高，大约是50～60%，网络带宽下降了接近一半。2台负载机器得到总的服务器的qps处理能力是3.7w左右，下降非常多。所以多连接情况下，NGINX处理效率没有那么高，资源利用率也相对低一些。</p>
<p>对比wrk和ab，似乎wrk可以产生更大的压力。</p>
<h3 id="使用jmeter执行测试"><a href="#使用jmeter执行测试" class="headerlink" title="使用jmeter执行测试"></a>使用jmeter执行测试</h3><p>上面使用ab和wrk测试的结果都已经出来，可以看到得到数据是类似的。现在可以使用ab和wrk测试得到qps作为被测服务的性能基准，可以认为较低并发（1k）的情况下被测服务的QPS能力约9.8w，较高并发（10w）情况下被测服务的QPS能力约3.3w。接下来再使用jmeter进行性能测试。</p>
<p>首先确认对jmeter进行了适当的优化，包括jmeter-server服务和jmter脚本，具体优化措施参考我另外一篇博文。</p>
<p>1）用例1： 高连接数，使用2台jmeter-server测试，每台创建1w个线程发送请求</p>
<p>在使用jmeter进行性能测试时，关闭所有断言，可以得到更好的测试效果。如果为了分析被测服务逻辑处理的正确率，可以在事后进行统计分析。</p>
<p>使用两台机器启动分布式命令，一台是192.168.1.181，一台是本机：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./jmeter -n -t test_nginx_benchmark.jmx -l test_nginx_benchmark.jtl -R192.168.1.181,localhost  -e -o test_nginx_benchmark -f</span><br></pre></td></tr></table></figure>

<p>性能在2.5w左右，而被测服务器的cpu利用率目测只有30%左右，效果与ab、wrk是接近的：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;Total&quot;</span> : &#123;</span><br><span class="line">  <span class="attr">&quot;transaction&quot;</span> : <span class="string">&quot;Total&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;sampleCount&quot;</span> : <span class="number">1000000</span>,</span><br><span class="line">  <span class="attr">&quot;throughput&quot;</span> : <span class="number">25401.986435339244</span>,</span><br><span class="line">  <span class="attr">&quot;receivedKBytesPerSec&quot;</span> : <span class="number">21160.053153656616</span>,</span><br><span class="line">  <span class="attr">&quot;sentKBytesPerSec&quot;</span> : <span class="number">4068.286890034801</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是在高连接的情况下，jmeter确实比ab或wrk更消耗资源。1w并发的情况下8核的总cpu利用率达到了80%（按总100%计算）。因为jmeter实际上是对每一个连接都建立了一个线程，所以每台负载机器在执行测试时都产生了约1w个线程。操作系统需要对这1w个线程进行调度，通过观察，CPU资源使用率大约是ab或wrk的2倍。</p>
<p>2）用例2： 低连接数，使用2台jmeter-server测试，每台创建500个线程发送请求</p>
<p>仍然是利用两台jmeter机器压测，但这次采用低连接模式，连接数少得多。每台机器启动一个jmeter-server服务进程，每个服务进程启动500个线程，与ab、wrk测试时一样，每个线程保持http连接keepalive，循环向服务端发送请求，每个线程共计循环约2000次。</p>
<p>这次测试得到的服务器QPS大约在5w。负载服务器的CPU利用率和用例1的情况类似，CPU利用率达到了极限。但服务器的CPU率没有达到极限，估计在50%左右。相比较用例1，由于负载机器的资源利用和工作模式更改，显然对服务器的压力更大了，但服务器显然还有处理余量，此时服务的QPS与使用wrk相比，只有一半左右。根据上述资源分析情况，可以看到jmeter确实比wrk、ab更消耗cpu，效率更低。在此次测试场景中，jmeter和负载机器成为了瓶颈。未来有机会，将尝试对jmeter和运行模式进行调优，降低对CPU的消耗率，使得能以较少的机器产生较多的负载量。</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="nginx配置文件示例"><a href="#nginx配置文件示例" class="headerlink" title="nginx配置文件示例"></a>nginx配置文件示例</h3><p>/etc/nginx/nginx.conf内容示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#v1.1:增加cpu亲和力设置;增加keepalive设置</span><br><span class="line">user nginx;</span><br><span class="line">worker_processes 8;</span><br><span class="line">worker_cpu_affinity 00000001 00000010 00000100 00001000 00010000 00100000 01000000 10000000;</span><br><span class="line"></span><br><span class="line">error_log /var/log/nginx/error.log crit;</span><br><span class="line">pid /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line">worker_rlimit_nofile 65535;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    #worker_connections  1024;</span><br><span class="line">    use epoll;</span><br><span class="line">    multi_accept on;</span><br><span class="line">    #在Nginx接到一个新连接通知后,调用accept()来接受尽量多的连接</span><br><span class="line">    worker_connections 65535;</span><br><span class="line">    #最大访问客户数,修改此值时,不能超过 worker_rlimit_nofile 值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    keepalive_timeout  120s 120s;</span><br><span class="line">    keepalive_requests 10000;</span><br><span class="line"></span><br><span class="line">    include /etc/nginx/mime.types;</span><br><span class="line">    default_type application/octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format main</span><br><span class="line">        &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">        &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">        &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line"></span><br><span class="line">    access_log /var/log/nginx/access.log main;</span><br><span class="line">    #GZIP性能优化</span><br><span class="line"></span><br><span class="line">    gzip on;</span><br><span class="line">    gzip_min_length 1100;</span><br><span class="line">    #对数据启用压缩的最少字节数,如:请求小于1K文件,不要压缩,压缩小数据会降低处理此请求的所有进程速度</span><br><span class="line">    gzip_buffers 4 16k;</span><br><span class="line">    gzip_proxied any;</span><br><span class="line">    #允许或者禁止压缩基于请求和响应的响应流,若设置为any,将会压缩所有请求</span><br><span class="line">    gzip_http_version 1.0;</span><br><span class="line">    gzip_comp_level 9;</span><br><span class="line">    #gzip压缩等级在0-9内,数值越大压缩率越高,CPU消耗也就越大</span><br><span class="line">    gzip_types text/plain</span><br><span class="line">        text/css</span><br><span class="line">        application/javascript</span><br><span class="line">        application/x-javascript</span><br><span class="line">        text/xml</span><br><span class="line">        application/xml</span><br><span class="line">        application/xml+rss</span><br><span class="line">        text/javascript</span><br><span class="line">        application/json</span><br><span class="line">        image/jpeg</span><br><span class="line">        image/gif</span><br><span class="line">        image/png;</span><br><span class="line">    #压缩类型</span><br><span class="line">    gzip_vary on;</span><br><span class="line">    #varyheader支持,让前端的缓存服务器识别压缩后的文件,代理</span><br><span class="line">    include /usr/local/nginx/conf/vhosts/*.conf;</span><br><span class="line">    #在当前文件中包含另一个文件内容的指令</span><br><span class="line"></span><br><span class="line">    #静态文件的缓存性能调优</span><br><span class="line"></span><br><span class="line">    open_file_cache max=65535 inactive=20s;</span><br><span class="line">    #这个将为打开文件指定缓存,max 指定缓存数量.建议和打开文件数一致.inactive 是指经过多长时间文件没被请求后删除缓存</span><br><span class="line">    open_file_cache_valid 30s;</span><br><span class="line">    #这个是指多长时间检查一次缓存的有效信息,例如我一直访问这个文件,30秒后检查是否更新,反之更新</span><br><span class="line">    open_file_cache_min_uses 2;</span><br><span class="line">    #定义了open_file_cache中指令参数不活动时间期间里最小的文件数</span><br><span class="line">    open_file_cache_errors on;</span><br><span class="line">    #NGINX可以缓存在文件访问期间发生的错误,这需要设置该值才能有效,如果启用错误缓存.则在访问资源（不查找资源）时.NGINX会报告相同的错误</span><br><span class="line"></span><br><span class="line">    sendfile on;</span><br><span class="line">    tcp_nopush on;</span><br><span class="line">    tcp_nodelay on;</span><br><span class="line">    #是否启用 nagle 缓存算法,告诉nginx不要缓存数据</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">    include /etc/nginx/conf.d/*.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="jmeter测试脚本"><a href="#jmeter测试脚本" class="headerlink" title="jmeter测试脚本"></a>jmeter测试脚本</h3><p>jmeter脚本比较简单，不过由于存储格式是xml，略显臃肿，仅贴出脚本截图。</p>
<p><img src="/images/jmeter5/benchmark/nginx-benchmark.png" alt="nginx-benchmark"></p>
<h3 id="统计ab测试结果的python脚本"><a href="#统计ab测试结果的python脚本" class="headerlink" title="统计ab测试结果的python脚本"></a>统计ab测试结果的python脚本</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> os, sys</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">计算多个ab进程测试的总qps。</span></span><br><span class="line"><span class="string">具体是计算当前目录下所有log中的 &quot;Requests per second:    3156.94 [#/sec] (mean)&quot;中包含的qps， 然后相加</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_qps</span>(<span class="params">text</span>):</span></span><br><span class="line">    pattern = <span class="string">r&#x27;Requests per second:\s*(.*)\s\[#/sec] \(mean\)&#x27;</span></span><br><span class="line">    ret = re.findall(pattern, text)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(ret) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> ret[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>  <span class="comment"># 如果没找到，可能出现了错误，暂时返回0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cur_dir = <span class="string">&quot;.&quot;</span></span><br><span class="line">total = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> root, <span class="built_in">dir</span>, files <span class="keyword">in</span> os.walk(cur_dir):</span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">        log = os.path.join(root, file)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> log.__contains__(<span class="string">&quot;.log&quot;</span>):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(log, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            text = f.read()</span><br><span class="line">            qps_text = get_qps(text)</span><br><span class="line">            qps_num = <span class="built_in">float</span>(qps_text)</span><br><span class="line">            total += qps_num</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;total qps is : &quot;</span>, total)</span><br></pre></td></tr></table></figure>

<h3 id="统计wrk测试结果python脚本"><a href="#统计wrk测试结果python脚本" class="headerlink" title="统计wrk测试结果python脚本"></a>统计wrk测试结果python脚本</h3><p>脚本与统计ab的逻辑一直的，模式上略有区别。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> os, sys</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">计算多个wrk进程测试的总qps。</span></span><br><span class="line"><span class="string">具体是计算当前目录下所有log中的 &quot;Requests/sec:  10099.83&quot;中包含的qps， 然后相加</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_qps</span>(<span class="params">text</span>):</span></span><br><span class="line">    <span class="comment">#pattern = r&#x27;Requests per second:\s*(.*)\s\[#/sec] \(mean\)&#x27;</span></span><br><span class="line">    <span class="comment">#Requests/sec:  10099.83</span></span><br><span class="line">    pattern = <span class="string">r&#x27;Requests/sec:\s*(.*)\s*&#x27;</span></span><br><span class="line">    ret = re.findall(pattern, text)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(ret) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> ret[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>  <span class="comment"># 如果没找到，可能出现了错误，暂时返回0</span></span><br><span class="line"></span><br><span class="line">cur_dir = <span class="string">&quot;.&quot;</span></span><br><span class="line">total = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> root, <span class="built_in">dir</span>, files <span class="keyword">in</span> os.walk(cur_dir):</span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">        log = os.path.join(root, file)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> log.__contains__(<span class="string">&quot;.log&quot;</span>):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(log, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            text = f.read()</span><br><span class="line">            qps_text = get_qps(text)</span><br><span class="line">            qps_num = <span class="built_in">float</span>(qps_text)</span><br><span class="line">            total += qps_num</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;total qps is : &quot;</span>, total)</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>Nginx高并发下的优化: <a href="https://segmentfault.com/a/1190000011405320">https://segmentfault.com/a/1190000011405320</a></li>
<li>CentOS7调优实践：<a href="https://johnny1952.github.io/2021/10/05/CentOS7%E8%B0%83%E4%BC%98%E5%AE%9E%E8%B7%B5/">https://johnny1952.github.io/2021/10/05/CentOS7%E8%B0%83%E4%BC%98%E5%AE%9E%E8%B7%B5/</a></li>
</ul>
]]></content>
      <categories>
        <category>jmeter</category>
      </categories>
      <tags>
        <tag>jmeter</tag>
        <tag>性能测试</tag>
      </tags>
  </entry>
</search>
